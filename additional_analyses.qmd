---
title: "additional_analyses"
author: "Liz Loutrage"
format: 
  html:
    self-contained: true
    code-fold: true
editor: source
keep-md: true
execute:
  warning: false
  message : false
toc: true
toc-title: Sections
toc-location: left
page-layout: full
theme: yeti
fontsize: medium
---

# Data preparation
```{r}
#| echo: false
#| label: morpho_data
#| warning: false

library(dplyr)
library(ggplot2)

morphometric_data <- utils::read.csv(here::here("data", "morphometric_data.csv"), sep = ";", header = T, dec = ".")

morpho_data <- morphometric_data %>%
  select(-c(variable_abbreviation, variable_unit)) %>%
  t() %>%
  as.data.frame() %>%
  janitor::row_to_names(row_number = 1) %>%
  `rownames<-`(NULL)%>%
  # delete for now (n=1)
  filter(species!= "Diaphus_sp")

# replace empty value by NA 
morpho_data[morpho_data ==""] <- NA

# Numeric variables
morpho_data[, 4:23] <- sapply(morpho_data[, 4:23], as.numeric)
```

__Data summary__
```{r}
#| echo: false
#| label: summary_data
#| warning: false

morpho_data_summary <-morpho_data %>%
  group_by(species) %>%
  count(species)

htmltools::tagList(DT::datatable(morpho_data_summary))
```


```{r}
#| echo: false
#| label: imputation_data
#| warning: false
#| message: false
#| fig-width: 13
#| fig-height: 9

#select numeric variables for imputation 
original_data <- morpho_data %>%
  select(1:23)

imputation <-
  mice::mice(
    original_data,
    m = 5,
    maxit = 20,
    printFlag = F
  )

imputed_data <- mice::complete(imputation)

```


```{r}
#| echo: false
#| label: functional_traits
#| warning: false
#| message: false

# calculate functional numeric traits
numeric_traits <- imputed_data %>%
  na.omit() %>%
  select(-individual_code) %>%
  mutate(
    eye_size = eye_diameter / head_depth,
    orbital_length = eye_diameter / standard_length,
    oral_gape_surface = mouth_width * mouth_depth / body_width * body_depth,
    oral_gape_shape = mouth_depth / mouth_width,
    oral_gape_position = distance_upper_jaws_bottom_head / head_depth,
    lower_jaw_length = lower_jaw_length / standard_length,
    head_length = head_length / standard_length,
    body_depth = body_depth / standard_length,
    pectoral_fin_position = distance_pectoral_bottom_body / body_depth_pectoral_insertion,
    pectoral_fin_insertion = prepectoral_length / standard_length,
    transversal_shape = body_depth / body_width,
    dorsal_fin_insertion = predorsal_length / standard_length,
    eye_position = eye_height / head_depth,
    operculum_volume = operculum_depth / operculum_width,
    gill_outflow = operculum_width,
    caudal_throttle_width = caudal_peduncle_min_depth
  ) %>%
  select(
    species,
    eye_size,
    orbital_length,
    gill_outflow,
    oral_gape_surface,
    oral_gape_shape,
    oral_gape_position,
    lower_jaw_length,
    head_length,
    body_depth,
    pectoral_fin_position,
    pectoral_fin_insertion,
    transversal_shape,
    caudal_throttle_width,
    dorsal_fin_insertion,
    eye_position,
    operculum_volume
  ) %>%
  group_by(species) %>%
  summarise(across(everything(), mean, na.rm = TRUE)) %>%
  arrange(species)

# categorical traits for species without NA
cat_morpho <- morpho_data %>%
  select(
    species,
    ventral_photophores,
    gland_head,
    chin_barbel,
    small_teeth,
    large_teeth,
    fang_teeth,
    #retractable_teeth,
    internal_teeth,
    gill_raker_types,
    oral_gape_axis
  ) %>%
    na.omit() %>%
  distinct() %>%
  arrange(species)

# combined the two data frames
fish_traits <- numeric_traits %>%
  inner_join(cat_morpho, by = "species") %>%
  arrange(species) %>% 
  tibble::column_to_rownames("species")%>%
  # assign trait type 
  # as.factor for qualitative traits
  mutate_if(is.character, as.factor)%>%
  # as.ordered for ordered variables
  mutate_at(c("gill_raker_types", "oral_gape_axis"), as.ordered)

```

```{r}
#| echo: false
#| label: sp_traits
#| warning: false
#| message: false

## Display the table ----
htmltools::tagList(DT::datatable(fish_traits))
```


## __Traits correlation__
- remove the traits that are too correlated?
```{r}
#| echo: true
#| label: traits_correlation
#| warning: false
#| message: false
#| fig-width: 8
#| fig-height: 10

M <-cor(numeric_traits[, c(-1)])

ggcorrplot::ggcorrplot(M, hc.order = TRUE, type = "lower",
                       lab = TRUE, tl.cex = 9, lab_size = 3)

```


```{r}
#| echo: false
#| label: nb_trawl
#| warning: false

# Metadata
metadata <-  utils::read.csv(here::here("data", "metadata.csv"), sep = ";", header = T, dec = ".")%>%
  # calculation of standardized biomass values (vertical  trawl opening * horizontal trawl opening * distance traveled)  
  mutate(volume_filtered = 24*58*distance)
```


```{r}
#| echo: false
#| label: taxonomic_families
#| warning: false

# list of species 
sp_names <- c(rownames(fish_traits), "Nannobrachium_atrum", "Cyclothone", "Stomias_boa_boa")

# taxonomic_families
taxonomic_families <- sp_names %>%
  as.data.frame() %>%
  `colnames<-`("species") %>% 
  mutate(
    family = case_when(
      species %in%
        c(
          "Benthosema_glaciale",
          "Ceratoscopelus_maderensis",
          "Diaphus_metopoclampus",
          "Lampanyctus_ater",
          "Lampanyctus_crocodilus",
          "Lampanyctus_macdonaldi",
          "Lobianchia_gemellarii",
          "Myctophum_punctatum",
          "Notoscopelus_bolini",
          "Notoscopelus_kroyeri",
          "Bolinichthys_supralateralis"
        ) ~ "Myctophidae",
      species %in% c(
        "Borostomias_antarcticus",
        "Chauliodus_sloani",
        "Malacosteus_niger",
        "Melanostomias_bartonbeani",
        "Stomias_boa"
      ) ~ "Stomiidae",
      species %in% c(
        "Holtbyrnia_anomala",
        "Holtbyrnia_macrops",
        "Maulisia_argipalla",
        "Maulisia_mauli",
        "Maulisia_microlepis",
        "Normichthys_operosus",
        "Searsia_koefoedi",
        "Sagamichthys_schnakenbecki"
      ) ~ "Platytroctidae",
      species %in% c("Sigmops_bathyphilus",
                     "Gonostoma_elongatum") ~ "Gonostomatidae",
      species %in% c(
        "Argyropelecus_hemigymnus",
        "Maurolicus_muelleri",
        "Argyropelecus_olfersii"
      ) ~ "Sternoptychidae",
      species == "Anoplogaster_cornuta" ~ "Anoplogastridae",
      species %in% c("Arctozenus_risso", "Paralepis_coregonoides") ~ "Paralepididae",
      species == "Bathylagus_euryops" ~ "Bathylagidae",
      species == "Cyclothone_sp" ~ "Gonostomatidae",
      species == "Derichthys_serpentinus" ~ "Derichthyidae",
      species == "Eurypharynx_pelecanoides" ~ "Eurypharyngidae",
      species == "Evermannella_balbo" ~ "Evermannellidae",
      species == "Lestidiops_sphyrenoides" ~ "Lestidiidae",
      species == "Melanostigma_atlanticum" ~ "Zoarcidae",
      species %in% c("Photostylus_pycnopterus",
                     "Xenodermichthys_copei") ~ "Alepocephalidae",
      species == "Serrivomer_beanii" ~ "Serrivomeridae"
    )
  ) %>% 
  mutate(
    order = case_when(
      family =="Myctophidae" ~ "Myctophiformes",
      family %in% c("Stomiidae","Gonostomatidae", "Sternoptychidae") ~  "Stomiiformes",
      family %in% c("Platytroctidae","Alepocephalidae") ~ "Alepocephaliformes",
      family == "Anoplogastridae" ~ "Trachichthyiformes",
      family %in% c("Paralepididae","Evermannellidae","Lestidiidae") ~ "Aulopiformes",
      family ==  "Bathylagidae" ~ "Argentiniformes",
      family %in% c("Derichthyidae","Serrivomeridae") ~ "Anguilliformes",
      family ==  "Eurypharyngidae" ~"Saccopharyngiformes",
      family == "Zoarcidae" ~ "Perciformes",
    )
  )


```

```{r}
#| echo: false
#| label: sp_depth_mt
#| warning: false

data_biomass_2002_2019 <- utils::read.csv(here::here("data", "Biomass_density_deep_pelagic_fish _Bay_of_Biscay.csv"), 
                                          sep = ";", header = TRUE, dec = ",")%>%
  rename( Code_Station= "Event.label") %>%
  select(Code_Station, 9:290) %>%
  mutate_all(~replace(., is.na(.), 0)) %>%
  select(c(contains("..g."),Code_Station)) %>%
  select(Code_Station, everything()) %>%
  select(-contains("..g.m3.")) %>% 
  rename_all(~gsub("\\.\\.g\\.", "", .)) %>% 
  rename_all(~gsub("\\.", "_", .)) %>% 
  tidyr::pivot_longer(cols = -Code_Station, names_to = "Nom_Scientifique", values_to = "Tot_V_HV") %>% 
  filter(Nom_Scientifique%in%sp_names)%>%
  filter(!Code_Station=="H0472")%>%
  replace(is.na(.), 0)

# species biomass x depth  matrix 2021 ----
data_biomass_2021 <- utils::read.csv(here::here("data", "data_evhoe_catch_2021.csv"), sep = ";", header = T, dec = ".")%>%
  select(Nom_Scientifique, Tot_V_HV, Code_Station)%>%
  distinct()%>%
  mutate(Nom_Scientifique= gsub(" ","_",Nom_Scientifique))%>%
  filter(Nom_Scientifique%in%sp_names)

# species biomass x depth  matrix 2022 ----
data_biomass_2022 <- utils::read.csv(here::here("data", "data_evhoe_catch_2022.csv"), sep = ";", header = T, dec = ".")%>%
  select(Nom_Scientifique, Tot_V_HV, Code_Station)%>%
  distinct()%>%
  mutate(Nom_Scientifique= gsub(" ","_",Nom_Scientifique))%>%
  filter(Nom_Scientifique%in%sp_names)

# #merge all matrix ----
depth_fish_biomass <- rbind(data_biomass_2002_2019, data_biomass_2021, data_biomass_2022)%>%
  as.data.frame()%>%
   rename("species"="Nom_Scientifique",
         "station"="Code_Station") %>%
  left_join(metadata) %>%
  select(species, Tot_V_HV, depth, volume_filtered)%>%
  # divise biomass by the volume filtered at each trawl (g.m3)
  mutate(biomass_cpu=(Tot_V_HV/volume_filtered)*1000)%>%
  select(species, depth, biomass_cpu)%>%
  # add column with depth layer
  mutate(
    depth_layer = case_when(
      between(depth, 0, 174) ~ "Epipelagic",
      between(depth, 175, 699) ~ "Upper mesopelagic",
      between(depth, 700, 999) ~ "Lower mesopelagic",
      between(depth, 1000, 2000) ~ "Bathypelagic"))%>%
  replace(is.na(.), 0)%>%
  select(-depth)%>%
  group_by(species, depth_layer)%>%
  mutate(biomass=sum(biomass_cpu))%>%
  select(-c(biomass_cpu))%>%
  distinct()%>%
  tidyr::pivot_wider(names_from = species, values_from = biomass)%>%
  replace(is.na(.), 0)%>%
  tibble::column_to_rownames(var = "depth_layer")%>%
  #change species name
  rename("Lampanyctus_ater"="Nannobrachium_atrum")%>%
  rename("Cyclothone_sp"="Cyclothone")%>%
  rename("Stomias_boa"="Stomias_boa_boa") %>%
  as.matrix()

```
- Traits types

```{r}
#| echo: false
#| label: fish_traits_cat
#| warning: false
#| message: false

fish_traits_cat <- utils::read.csv(here::here("data", "fish_traits_cat.csv"), sep = ";", header = T, dec = ".") %>% 
  filter(trait_name!="retractable_teeth")

```



```{r}
#| echo: false
#| label: sum_assem_sp
#| warning: false
#| message: false

## Summary of the assemblages * species data.frame ----
asb_sp_fish_summ <- mFD::asb.sp.summary(asb_sp_w = depth_fish_biomass)
asb_sp_fish_occ  <- asb_sp_fish_summ$"asb_sp_occ"

```


```{r}
#| echo: false
#| label: dist_fish
#| warning: false
#| message: false

sp_dist_fish <- mFD::funct.dist(
  sp_tr         = fish_traits,
  tr_cat        = fish_traits_cat,
  metric        = "gower",
  scale_euclid  = "scale_center",
  ordinal_var   = "classic",
  weight_type   = "equal",
  stop_if_NA    = TRUE)

## Output of the function mFD::funct.dist() ----
#round(sp_dist_fish, 3)

```



```{r}
#| echo: false
#| label: fspaces_quality_fish
#| warning: false
#| message: false

fspaces_quality_fish <- mFD::quality.fspaces(
  sp_dist             = sp_dist_fish,
  maxdim_pcoa         = 10,
  deviation_weighting = "absolute",
  fdist_scaling       = FALSE,
  fdendro             = "average")

## Quality metrics of functional spaces ----
#round(fspaces_quality_fish$"quality_fspaces", 3)

```


```{r}
#| echo: false
#| label: variance_explained
#| warning: false
#| message: false

# Extract eigenvalues information
eigenvalues_info <- fspaces_quality_fish$"details_fspaces"$"pc_eigenvalues"

# Create a dataframe to store the results
variance_df <- data.frame(
  PC = c("PC1", "PC2", "PC3", "PC4"),
  VarianceExplained = c(
    eigenvalues_info[1, "Cum_corr_eig"] * 100,
    (eigenvalues_info[2, "Cum_corr_eig"] - eigenvalues_info[1, "Cum_corr_eig"]) * 100,
    (eigenvalues_info[3, "Cum_corr_eig"] - eigenvalues_info[2, "Cum_corr_eig"]) * 100,
    (eigenvalues_info[4, "Cum_corr_eig"] - eigenvalues_info[3, "Cum_corr_eig"]) * 100
  )
)

#htmltools::tagList(DT::datatable(variance_df))

```



```{r}
#| echo: false
#| label: test_correlation
#| warning: false
#| message: false
#| fig-width: 14
#| fig-height: 9

sp_faxes_coord_fish <- fspaces_quality_fish$"details_fspaces"$"sp_pc_coord"

# As we have 26 traits we have to split the df to see correlation between functional axes and traits 
# first set ----
fish_traits_1 <- fish_traits%>%
  select(1:9)

fish_tr_faxes <- mFD::traits.faxes.cor(
  sp_tr          = fish_traits_1, 
  sp_faxes_coord = sp_faxes_coord_fish[ , c("PC1", "PC2", "PC3", "PC4")], 
  plot           = T)

# ## Print traits with significant effect ----
# fish_tr_faxes$"tr_faxes_stat"[which(fish_tr_faxes$"tr_faxes_stat"$"p.value" < 0.05), ]
# 
# ## Plot ----
# fish_tr_faxes$"tr_faxes_plot"
```

```{r}
#| echo: false
#| label: test_correlation_2
#| warning: false
#| message: false
#| fig-width: 14
#| fig-height: 9

# second set ----
fish_traits_2 <- fish_traits%>%
  select(10:18)

fish_tr_faxes_2 <- mFD::traits.faxes.cor(
  sp_tr          = fish_traits_2, 
  sp_faxes_coord = sp_faxes_coord_fish[ , c("PC1", "PC2", "PC3", "PC4")], 
  plot           = T)

# ## Print traits with significant effect ----
# fish_tr_faxes_2$"tr_faxes_stat"[which(fish_tr_faxes_2$"tr_faxes_stat"$"p.value" < 0.05), ]
# 
# ## Plot ----
# fish_tr_faxes_2$"tr_faxes_plot"
```


```{r}
#| echo: false
#| label: test_correlation_3
#| warning: false
#| message: false
#| fig-width: 14
#| fig-height: 9

# third set ----
fish_traits_3 <- fish_traits%>%
  select(19:25)

fish_tr_faxes_3 <- mFD::traits.faxes.cor(
  sp_tr          = fish_traits_3, 
  sp_faxes_coord = sp_faxes_coord_fish[ , c("PC1", "PC2", "PC3", "PC4")], 
  plot           = T)

# ## Print traits with significant effect ----
# fish_tr_faxes_3$"tr_faxes_stat"[which(fish_tr_faxes_3$"tr_faxes_stat"$"p.value" < 0.05), ]
# 
# ## Plot ----
# fish_tr_faxes_3$"tr_faxes_plot"

```



```{r}
#| echo: false
#| label: traits_effect_list
#| warning: false
#| message: false

sp_faxes_coord_fish <- fspaces_quality_fish$"details_fspaces"$"sp_pc_coord"

fish_tr_faxes <- mFD::traits.faxes.cor(
  sp_tr          = fish_traits, 
  sp_faxes_coord = sp_faxes_coord_fish[ , c("PC1", "PC2", "PC3", "PC4")], 
  plot           = F)

## Print traits with significant effect ----
traits_effect <- fish_tr_faxes[which(fish_tr_faxes$p.value< 0.05),] %>% 
  as.data.frame() %>% 
  arrange(axis, desc(value))

#htmltools::tagList(DT::datatable(traits_effect))

```


```{r}
#| echo: false
#| label: plot_functional_space
#| warning: false
#| message: false
#| fig-width: 8
#| fig-height: 8

sp_faxes_coord_fish <- fspaces_quality_fish$"details_fspaces"$"sp_pc_coord"

big_plot <- mFD::funct.space.plot(
  sp_faxes_coord  = sp_faxes_coord_fish[ , c("PC1", "PC2", "PC3", "PC4")],
  faxes           = c("PC1", "PC2", "PC3", "PC4"),
  name_file       = NULL,
  faxes_nm        = NULL,
  range_faxes     = c(NA, NA),
  plot_ch         = TRUE,
  shape_pool      = 20,
  size_pool = 2.5,
  size_vert = 1.5,
  color_ch = "darkgrey",
  color_vert      = "black",
  fill_vert       = "black",
  color_pool = "grey",
  plot_vertices   = TRUE,
  check_input     = TRUE)


```

# CWM bootstrap
## By depth layer 

- each trawl is a replica 

- Utilisation traitstrap R package

- Bootstrap non parametric, échantillonnage dans les proportions de la biomasse des espèces 

- pour le remplissage des valeurs manquantes : si manque données pour 1 individus alors va chercher la valeurs sur un ind de la même profondeur, si pas possible alors ind à une autre profondeur mais de la même couche et si impossible ind d'une autre couche de profondeur 
```{r}
#| echo: true
#| label: CWM_boot
#| warning: false
#| message: false
#| fig-width: 11
#| fig-height: 9

spxcom.matrix <-  depth_fish_biomass %>% 
  t() %>% 
  as.data.frame() %>% 
  relocate("Epipelagic", "Upper mesopelagic", "Lower mesopelagic","Bathypelagic" ) %>% 
  tibble::rownames_to_column("species") %>% 
  arrange(species) %>% 
  tibble::column_to_rownames("species") %>% 
  as.matrix()

spxtraits.matrix <- fish_traits %>%
  mutate(across(16:23, ~ case_when(. == "P" ~ 1, 
                                   . == "A" ~ 0, 
                                   TRUE ~ as.numeric(.))),
         across(24, ~ case_when(. == "A" ~ 1, 
                                . == "B" ~ 2, 
                                . == "C" ~ 3, 
                                TRUE ~ as.numeric(.)))) %>% 
  select(-c(gill_raker_types, oral_gape_axis)) %>% 
  as.matrix()

# Remove the "[,1]" suffix from column names
names(spxtraits.matrix) <- gsub("[,1]", "", names(spxtraits.matrix))

#check rownames
#rownames(spxtraits.matrix) == rownames(spxcom.matrix)

result_CWM <- FD::functcomp(spxtraits.matrix, t(spxcom.matrix)) 
#FD::functcomp(spxtraits.matrix, t(spxcom.matrix), CWM.type = "all")

#  Calculate Total biomass
total_biomass <- colSums(spxcom.matrix)

#  Calculate Relative biomass
sp_rel_biomass <- t(spxcom.matrix) / total_biomass

# Transpose the Relative biomass Matrix for Display
t_sp_rel_biomass <- t(sp_rel_biomass)

total_sum <- colSums(t(sp_rel_biomass))

# Initialize an empty data frame to store results
CWM_df <- data.frame(
  depth_layer = character(),
  trait = character(),
  total_sum = numeric(),
  weighted_mean = numeric(),
  stringsAsFactors = FALSE
)

library(traitstrap)

# Trait 
trait_boot <- morpho_data%>% 
  inner_join(metadata) %>% 
  select(-c(individual_code, years, longitude_start,
            latitude_start, longitude_end, longitude_end,
            volume_filtered, distance)) %>% 
  mutate(
    eye_size = eye_diameter / head_depth,
    orbital_length = eye_diameter / standard_length,
    oral_gape_surface = mouth_width * mouth_depth / body_width * body_depth,
    oral_gape_shape = mouth_depth / mouth_width,
    oral_gape_position = distance_upper_jaws_bottom_head / head_depth,
    lower_jaw_length = lower_jaw_length / standard_length,
    head_length = head_length / standard_length,
    body_depth = body_depth / standard_length,
    pectoral_fin_position = distance_pectoral_bottom_body / body_depth_pectoral_insertion,
    pectoral_fin_insertion = prepectoral_length / standard_length,
    transversal_shape = body_depth / body_width,
    dorsal_fin_insertion = predorsal_length / standard_length,
    eye_position = eye_height / head_depth,
    operculum_volume = operculum_depth / operculum_width,
    gill_outflow = operculum_width,
    caudal_throttle_width = caudal_peduncle_min_depth
  ) %>%
  select(
    depth,
    species,
    eye_size,
    orbital_length,
    gill_outflow,
    oral_gape_surface,
    oral_gape_shape,
    oral_gape_position,
    lower_jaw_length,
    head_length,
    body_depth,
    pectoral_fin_position,
    pectoral_fin_insertion,
    transversal_shape,
    caudal_throttle_width,
    dorsal_fin_insertion,
    eye_position,
    operculum_volume,
    ventral_photophores, 
    gland_head,
    chin_barbel, 
    small_teeth, 
    large_teeth, 
    fang_teeth, 
    retractable_teeth, 
    internal_teeth
  ) %>%
  mutate_at(vars(ventral_photophores, 
                 gland_head,
                 chin_barbel, 
                 small_teeth, 
                 large_teeth, 
                 fang_teeth, 
                 retractable_teeth, 
                 internal_teeth), 
            funs(ifelse(. == "P", 1, ifelse(. == "A", 0, .)))) %>% 
  mutate(across(all_of(c("ventral_photophores", 
                         "gland_head",
                         "chin_barbel", 
                         "small_teeth", 
                         "large_teeth", 
                         "fang_teeth", 
                         "retractable_teeth", 
                         "internal_teeth")), as.numeric)) %>% 
  tidyr::pivot_longer(!c(species,depth), names_to = "trait", values_to = "values")%>%
  # add column with depth layer
  mutate(
    depth_layer = case_when(
      between(depth, 0, 174) ~ "Epipelagic",
      between(depth, 175, 699) ~ "Upper mesopelagic",
      between(depth, 700, 999) ~ "Lower mesopelagic",
      between(depth, 1000, 2000) ~ "Bathypelagic"))

# Community 
community <-  rbind(data_biomass_2002_2019, data_biomass_2021, data_biomass_2022)%>%
  as.data.frame()%>%
  rename("species"="Nom_Scientifique",
         "station"="Code_Station") %>%
  left_join(metadata) %>%
  select(species, Tot_V_HV, depth, volume_filtered)%>%
  # add column with depth layer
  mutate(
    depth_layer = case_when(
      between(depth, 0, 174) ~ "Epipelagic",
      between(depth, 175, 699) ~ "Upper mesopelagic",
      between(depth, 700, 999) ~ "Lower mesopelagic",
      between(depth, 1000, 2000) ~ "Bathypelagic"))%>%
  replace(is.na(.), 0)%>%
  group_by(species, depth)%>%
  mutate(biomass=sum(Tot_V_HV))%>%
  select(-c(Tot_V_HV))%>%
  distinct()%>%
  select(-c(volume_filtered)) %>% 
  filter(biomass>0) %>% 
  mutate(species = case_when(
    species == "Nannobrachium_atrum"~"Lampanyctus_ater",
    species == "Cyclothone"~"Cyclothone_sp",
    species == "Stomias_boa_boa"~"Stomias_boa",
    TRUE ~ species
  )) 

trait_filling <- trait_fill(
  # input data (mandatory)
  comm = community,
  traits = trait_boot,
  
  # specifies columns in your data (mandatory)
  abundance_col = "biomass",
  taxon_col = "species",
  trait_col = "trait",
  value_col = "values",
  
  # specifies sampling hierarchy
  scale_hierarchy = c("depth_layer", "depth"),
  
  # min number of samples
  min_n_in_sample = 5
)

# run nonparametric bootstrapping
np_bootstrapped_moments <- trait_np_bootstrap(
  trait_filling, 
  nrep = 100
)

np_bootstrapped_moments_plot <- np_bootstrapped_moments %>% 
  mutate(trait= gsub("_"," ", trait))%>%
  filter(
    trait %in% c(
      "caudal throttle width",
      "oral gape surface",
       "gill outflow",
      "large teeth",
       "small teeth",
      "orbital length",  
      "eye size",
      "transversal shape",
      "operculum volume",
      "ventral photophores",
      "internal teeth",
      "eye position",
      "oral gape shape"
    )
  )

np_bootstrapped_moments_plot$trait <- factor(
  np_bootstrapped_moments_plot$trait,
  levels = c(
    "caudal throttle width",
     "oral gape surface",
    "gill outflow",
    "large teeth",
    "small teeth",
    "orbital length",
    "eye size",
    "transversal shape",
    "operculum volume",
    "ventral photophores",
    "internal teeth",
    "eye position",
    "oral gape shape"
  )
)

np_bootstrapped_moments_plot$depth_layer <- factor(np_bootstrapped_moments_plot$depth_layer, 
                                                   levels = c("Epipelagic", "Upper mesopelagic", "Lower mesopelagic", "Bathypelagic"))

# Mean
ggplot(np_bootstrapped_moments_plot, aes(x=depth_layer, y=mean)) +
  geom_boxplot(aes(col=depth_layer, fill=depth_layer), alpha=0.08) +
  scale_fill_manual(values = c("#FEA520","#D62246","#6255B4","#3C685A"))+
  scale_color_manual(values = c("#FEA520","#D62246","#6255B4","#3C685A"))+
  guides(col="none", fill="none")+
  labs(y="Bootstrapped CWM")+
  facet_wrap(~trait, scales = "free")+
  theme_light()+
  theme(axis.text.x = element_blank(), 
        axis.title.x = element_blank(), 
        panel.grid.minor =  element_blank(),
        axis.title.y.left =  element_text(size =14), 
        strip.text = element_text( face="bold"),  
        axis.title.y = element_text(size=15),
        axis.text.y = element_text(size=14),
        strip.background=element_rect(fill="white"),
        strip.text.x = element_text(size = 14, color = "black"))

ggsave("CWM_boot.png", path = "figures/additional_analyses", dpi = 700, height = 10, width = 12)
```
### PCA CWM 

```{r}
#| echo: true
#| label: CWM_PCA
#| warning: false
#| message: false
#| fig-width: 9
#| fig-height: 6

sum_boot_moment <- trait_summarise_boot_moments(
  np_bootstrapped_moments
) %>% 
  ungroup() %>% 
  filter(
    trait %in% c(
      "caudal_throttle width",
      "oral_gape_surface",
      "gill_outflow",
      "large_teeth",
      "small_teeth",
      "orbital_length",  
      "eye_size",
      "transversal_shape",
      "operculum_volume",
      "ventral_photophores",
      "internal_teeth",
      "eye_position",
      "oral_gape_shape"
    )
  ) %>% 
  mutate(trait= gsub("_"," ", trait)) %>% 
  select(c(trait, depth_layer, mean)) %>% 
  group_by(
    depth_layer, trait
  ) %>% 
  summarise(mean_value= mean(mean)) %>% 
  distinct() %>% 
  ungroup() %>% 
  tidyr::pivot_wider(id_cols=depth_layer, values_from = "mean_value", names_from = "trait") %>% 
  tibble::column_to_rownames(var = "depth_layer")

res.pca <- FactoMineR::PCA(sum_boot_moment, graph = FALSE)

factoextra::fviz_pca_biplot(res.pca, repel = TRUE,
                            col.var = "gray50", 
                            col.ind = "black", 
                            pointsize = 2,
                            arrowsize = 0.2,
                            title = "", 
                            label = "var")+
  theme_light()+
  theme(panel.grid.minor =  element_blank(),
        panel.grid.major = element_blank())

ggsave("PCA_CWM.png", path = "figures/additional_analyses", dpi = 700, height = 5, width = 7)


```

### Summarizes bootstrapping output
```{r}
#| echo: false
#| label: boot_sum
#| warning: false
#| message: false

# summarizes bootstrapping output
sum_boot_moment <- trait_summarise_boot_moments(
  np_bootstrapped_moments
)

htmltools::tagList(DT::datatable(sum_boot_moment))
```


```{r}
#| echo: false
#| label: kruskal_test
#| warning: false
#| message: false

# Function to apply Kruskal-Wallis test and effect size calculation to each group
# kruskal_with_effsize <- function(data, trait_name) {
#   kruskal_res <- rstatix::kruskal_test(data, mean ~ depth_layer)
#   effsize_res <- rstatix::kruskal_effsize(data, mean ~ depth_layer)
#   combined_res <- cbind(trait = trait_name, kruskal_res, effsize_res)
#   return(combined_res)
# }
# 
# # Perform the Kruskal-Wallis test and calculate the eta² statistic for each trait
# res.kruskal <- np_bootstrapped_moments_plot %>%
#   group_by(trait) %>%
#   group_map(~ kruskal_with_effsize(.x, .y$trait)) %>%
#   bind_rows()
# 
# # View the results
# htmltools::tagList(DT::datatable(res.kruskal))
```

### Extracting raw distributions
```{r}
#| echo: true
#| label: raw_distribution
#| warning: false
#| message: false
#| fig-width: 10
#| fig-height: 8

# run nonparametric bootstrapping
raw_dist_np <- trait_np_bootstrap(
  filled_traits = trait_filling,
  raw = TRUE
)

raw_dist_np$depth_layer <- factor(
  raw_dist_np$depth_layer,
  levels = c(
    "Epipelagic",
    "Upper mesopelagic",
    "Lower mesopelagic",
    "Bathypelagic"
  )
) 

raw_dist_np <- raw_dist_np%>% 
    mutate(trait= gsub("_"," ", trait)) %>% 
  filter(!trait%in% c("chin barbel", "fang teeth", 
                      "gland head", "internal teeth",
                      "large teeth", "retractable teeth", 
                      "small teeth", "ventral photophores"))

ggplot(raw_dist_np, aes(x = log(values), fill = depth_layer, col= depth_layer)) +
  geom_density(alpha = 0.1) +
  scale_color_manual(values = c("#FEA520","#D62246","#6255B4","#3C685A"))+
  scale_fill_manual(values = c("#FEA520","#D62246","#6255B4","#3C685A"))+
  labs(x = " log(Trait value)") +
  guides(col="none", fill="none")+
  facet_wrap(facets = vars(trait), scales = "free")+
  theme_light()+
  theme(strip.text.x = element_text(size = 10, face = "bold", color="black"),
    strip.background = element_rect(fill = "white"),
    axis.title = element_text(size = 10),
    axis.text = element_text(size = 10))
```

# Functional redundancy 

- __Species Richness (N)__ 

- __Simpson diversity (D)__ :  probability that two individuals randomly selected from a sample will belong to the same species

- __Rao diversity (Q)__ : Sum of distances between pairs of randomly chosen species in trait space weighted by a relative abundance

- __Functionnal redundancy Ricotta et al. (2016)__ = 1-Q/D

```{r}
#| echo: true
#| label: diversity_Rao
#| warning: false
#| message: false
#| fig-width: 8
#| fig-height: 6

#Depth biomass data 
depth_fish_biomass_indices <- rbind(data_biomass_2002_2019, data_biomass_2021, data_biomass_2022)%>%
  as.data.frame()%>%
  rename("species"="Nom_Scientifique",
         "station"="Code_Station") %>%
  left_join(metadata) %>%
  select(species, Tot_V_HV, depth, volume_filtered, depth)%>%
  # divise biomass by the volume filtered at each trawl (g.m3)
  mutate(biomass_cpu=(Tot_V_HV/volume_filtered)*1000)%>%
  select(species, depth, biomass_cpu)%>%
  replace(is.na(.), 0)%>%
  group_by(species, depth)%>%
  mutate(biomass=sum(biomass_cpu))%>%
  select(-c(biomass_cpu))%>%
  distinct()%>%
  arrange(depth) %>% 
  tidyr::pivot_wider(names_from = species, values_from = biomass)%>%
  replace(is.na(.), 0)%>%
  tibble::column_to_rownames(var = "depth")%>%
  #change species name
  rename("Lampanyctus_ater"="Nannobrachium_atrum")%>%
  rename("Cyclothone_sp"="Cyclothone")%>%
  rename("Stomias_boa"="Stomias_boa_boa") %>%
  as.matrix()

# Species richness ----
nsp <- as.data.frame(vegan::specnumber(depth_fish_biomass_indices)) %>%
  tibble::rownames_to_column(var = "depth") %>% 
  mutate(depth=as.numeric(depth))
colnames(nsp) <- c("depth", "species_richness")

# Diversity indices
diversity_indices_list <- SYNCSA::rao.diversity(depth_fish_biomass_indices, traits = fish_traits) 

diversity_indices <- data.frame(diversity_indices_list[c(2:3)]) %>% 
  tibble::rownames_to_column(var = "depth") %>% 
  mutate(depth=as.numeric(depth)) %>% 
  inner_join(nsp) %>% 
  mutate(functionnal_redundancy_ricotta= 1-(FunRao/Simpson)) %>% 
  tidyr::pivot_longer(! depth, names_to = "indices") %>% 
  # add column with depth layer
  mutate(
    depth_layer = case_when(
      between(depth, 0, 174) ~ "Epipelagic",
      between(depth, 175, 699) ~ "Upper mesopelagic",
      between(depth, 700, 999) ~ "Lower mesopelagic",
      between(depth, 1000, 2000) ~ "Bathypelagic"))

diversity_indices$depth_layer <-
  factor(
    diversity_indices$depth_layer,
    levels = c(
      "Epipelagic",
      "Upper mesopelagic",
      "Lower mesopelagic",
      "Bathypelagic"
    )
  )

diversity_indices$indices <- factor(
  diversity_indices$indices,
  levels = c(
    "species_richness",
    "Simpson",
    "FunRao",
    "functionnal_redundancy_ricotta"
  ),
  labels = c(
    "Species richness (N)",
    "Simpson diversity (D)",
    "Rao diversity (Q)",
    "Functional Redundancy R=1-(Q/D)"
  )
)

ggplot(diversity_indices, aes(x = depth, y = value)) +
  geom_point(alpha = 0.5, size = 1.5) +
  geom_smooth(method = "lm", col = "#008E9B", alpha = 0.1) +
  facet_wrap(~indices, scales = "free") +
  ggpmisc::stat_poly_eq(formula = y ~ x, 
                        aes(label = paste(..rr.label.., ..p.value.label.., ..n.label.., sep = "*`,`~")), 
                        parse = TRUE, 
                        hjust = 0, vjust = 1) +
  theme_light() +
  theme(axis.title.y.left = element_text(size = 14), 
        strip.text = element_text(size = 14, face = "bold"),  
        legend.title = element_text(size = 11),  
        legend.text = element_text(size = 11), 
        axis.title.y = element_text(size = 11),
        axis.text.y = element_text(size = 12),
        strip.background = element_rect(fill = "white"),
        strip.text.x = element_text(size = 11, face = "bold", color = "black"))
```

```{r}
#| echo: true
#| label: diversity_Rao_boxplot
#| warning: false
#| message: false
#| fig-width: 8
#| fig-height: 6

ggplot(diversity_indices, aes(x =depth_layer, y=value))+
  geom_boxplot(aes(col=depth_layer, fill=depth_layer), alpha=0.1) +
  scale_fill_manual(values = c("#FEA520","#D62246","#6255B4","#3C685A"))+
  scale_color_manual(values = c("#FEA520","#D62246","#6255B4","#3C685A"))+
  facet_wrap(~indices, scales = "free")+
  theme_light()+
  guides(col="none", fill="none")+
  theme(axis.text.x = element_blank(), 
        axis.title.x = element_blank(), 
        axis.title.y.left =  element_text(size =14), 
        strip.text = element_text(size =14, face="bold"),  
        legend.title = element_text(size =11),  
        legend.text = element_text(size =11), 
        axis.title.y = element_text(size=11),
        axis.text.y = element_text(size=12),
        strip.background=element_rect(fill="white"),
        strip.text.x = element_text(size = 10, face = "bold", color = "black"))

```


```{r}
#| echo: true
#| label: ses
#| warning: false
#| message: false
#| fig-width: 9
#| fig-height: 4

# # Data Preparation 
# station_morpho <- morpho_data %>% 
#   select(station) %>% 
#   filter(!station%in%c("F0315", "F0367","X0568")) %>%  
#   arrange(station) %>%
#   distinct()
# 
# station_sp <- rbind(data_biomass_2002_2019, data_biomass_2021, data_biomass_2022) %>%
#   as.data.frame() %>%
#   rename("species"="Nom_Scientifique",
#          "station"="Code_Station") %>%
#   left_join(metadata) %>%
#   select(species, Tot_V_HV, volume_filtered, station) %>%
#   # divise biomass by the volume filtered at each trawl (g.m3)
#   mutate(biomass_cpu=(Tot_V_HV/volume_filtered)*1000) %>%
#   select(species, biomass_cpu, station) %>%
#   replace(is.na(.), 0) %>%
#   group_by(species, station) %>%
#   mutate(biomass=sum(biomass_cpu)) %>%
#   select(-c(biomass_cpu)) %>%
#   distinct() %>%
#   tidyr::pivot_wider(names_from = species, values_from = biomass) %>%
#   replace(is.na(.), 0) %>%
#   arrange(station) %>%
#   filter(station %in% station_morpho$station) %>%
#   tibble::column_to_rownames(var = "station") %>%
#   #change species name
#   rename("Lampanyctus_ater"="Nannobrachium_atrum") %>%
#   rename("Cyclothone_sp"="Cyclothone") %>%
#   rename("Stomias_boa"="Stomias_boa_boa") %>%
#   as.matrix()
# 
# # Null Model Analysis
# nb_rep <- 1000
# 
# resultsRandom_FunRao <-
#   matrix(
#     NA,
#     nrow = nrow(station_sp),
#     ncol = nb_rep,
#     dimnames = list(rownames(station_sp),
#                     paste0("Sim.", 1:nb_rep))
#   )
# 
# resultsRandom_FunRedundancy <-
#   matrix(
#     NA,
#     nrow = nrow(station_sp),
#     ncol = nb_rep,
#     dimnames = list(rownames(station_sp),
#                     paste0("Sim.", 1:nb_rep))
#   )
# 
# for (rep in 1:nb_rep) {
#   randomize_mx <- picante::randomizeMatrix(samp = station_sp,
#                                            null.model =  "frequency",
#                                            iterations = 100)
#   
#   sim_cal <- SYNCSA::rao.diversity(randomize_mx , traits = fish_traits)
#   sim_FunRao <- sim_cal$FunRao
#   sim_FunRedundancy <- sim_cal$FunRedundancy
#   
#   resultsRandom_FunRao[, rep] <- sim_FunRao
#   resultsRandom_FunRedundancy[, rep] <- sim_FunRedundancy
# }
# 
# # Comparison with Observed Values
# obs <- SYNCSA::rao.diversity(station_sp, fish_traits)
# obs_FunRao <- obs$FunRao
# obs_FunRedundancy <- obs$FunRedundancy
# 
# # Calculate mean and standard deviation of null model FD values for FunRao
# meanNull_FunRao <- rowMeans(resultsRandom_FunRao, na.rm = TRUE)
# sdNull_FunRao <- apply(resultsRandom_FunRao, 1, sd, na.rm = TRUE)
# 
# # Calculate mean and standard deviation of null model FD values for FunRedundancy
# meanNull_FunRedundancy <- rowMeans(resultsRandom_FunRedundancy, na.rm = TRUE)
# sdNull_FunRedundancy <- apply(resultsRandom_FunRedundancy, 1, sd, na.rm = TRUE)
# 
# # Calculate effect size and standardized effect size for FunRao
# ES_FunRao <- obs_FunRao - meanNull_FunRao
# SES_FunRao <- ES_FunRao / sdNull_FunRao
# 
# # Calculate effect size and standardized effect size for FunRedundancy
# ES_FunRedundancy <- obs_FunRedundancy - meanNull_FunRedundancy
# SES_FunRedundancy <- ES_FunRedundancy / sdNull_FunRedundancy
# 
# # Combine the results into a data frame
# result_fd_df <- data.frame(
#   station = rownames(station_sp),
#   SES_FunRao = SES_FunRao,
#   SES_FunRedundancy = SES_FunRedundancy
# ) %>%
#   inner_join(metadata) %>%
#   select(
#     -c(
#       latitude_start,
#       longitude_start,
#       latitude_end,
#       longitude_end,
#       duration,
#       distance,
#       volume_filtered,
#       years,
#       comments,
#       station
#     )
#   ) %>% 
#   mutate(
#     depth_layer = case_when(
#       between(depth, 0, 174) ~ "Epipelagic",
#       between(depth, 175, 699) ~ "Upper mesopelagic",
#       between(depth, 700, 999) ~ "Lower mesopelagic",
#       between(depth, 1000, 2000) ~ "Bathypelagic"
#     )
#   ) %>% 
#   tidyr::pivot_longer(!c(depth, depth_layer), values_to = "values", names_to = "indice")
# 
# result_fd_df$depth_layer <- factor(result_fd_df$depth_layer, 
#                                    levels = c("Epipelagic", "Upper mesopelagic",
#                                               "Lower mesopelagic", "Bathypelagic"))
# 
# # Plot
# ggplot(result_fd_df, aes(x = depth_layer)) +
#   geom_point(aes(y = values, col=depth_layer), alpha=0.4) +
#   facet_wrap(~indice)+
#   geom_boxplot(aes(y = values, col=depth_layer, fill=depth_layer), alpha=0.07) +
#   scale_color_manual(values = c("#FEA520","#D62246","#6255B4","#3C685A")) +
#   scale_fill_manual(values = c("#FEA520","#D62246","#6255B4","#3C685A")) +
#   labs(x="") +
#    theme_light()+
#   guides(col="none", fill="none")+
#   theme(axis.text.x = element_blank(), 
#         axis.title.x = element_blank(), 
#         axis.title.y.left =  element_text(size =14), 
#         strip.text = element_text(size =14, face="bold"),  
#         legend.title = element_text(size =11),  
#         legend.text = element_text(size =11), 
#         axis.title.y = element_text(size=11),
#         axis.text.y = element_text(size=12),
#         strip.background=element_rect(fill="white"),
#         strip.text.x = element_text(size = 10, face = "bold", color = "black"))+
#   geom_hline(yintercept=0, linetype="dashed", color = "black", linewidth=0.8)

```


# SES Functional diversity indices 

- __Standard Effect Size (SES):__ to eliminate the influence of species richness on the functional diversity indices (Mouchet et al., 2010). Measures the deviation from the random expectation in standard deviation units

- __null model frequency__: Randomize community data matrix abundances (here biomasss) within species (maintains species occurence frequency)

- __FRic Functional Richness__: the proportion of functional space filled by species of the studied assemblage, i.e. the volume inside the convex-hull shaping species. To compute FRic the number of species must be at least higher than the number of functional axis + 1.

- __FDis Functional Dispersion__: the biomass weighted deviation of species traits values from the center of the functional space filled by the assemblage i.e. the biomass-weighted mean distance to the biomass-weighted mean trait values of the assemblage.

- __FDiv Functional Divergence__: the proportion of the biomass supported by the species with the most extreme functional traits i.e. the ones located close to the edge of the convex-hull filled by the assemblage.

- __FEve Functional Evenness__: the regularity of biomass distribution in the functional space using the Minimum Spanning Tree linking all species present in the assemblage.

- __FOri Functional Originality__: the weighted mean distance to the nearest species from the global species pool.

- __FSpe Functional Specialization__: the biomass weighted mean distance to the mean position of species from the global pool (present in all assemblages).

- __FNND Functional Mean Nearest Neighbour Distance__: the weighted distance to the nearest neighbor within the assemblage

- __FMPD Functional Mean Pairwise Distance__: the mean weighted distance between all species pairs.

```{r}
#| echo: true
#| label: ses_mfd
#| warning: false
#| message: false
#| fig-width: 10
#| fig-height: 8

# Data Preparation ----
station_morpho <- morpho_data %>% 
  select(station) %>% 
  filter(!station %in% c("F0315", "F0367", "X0568")) %>%  
  arrange(station) %>%
  distinct()

station_sp <- rbind(data_biomass_2002_2019, data_biomass_2021, data_biomass_2022) %>%
  as.data.frame() %>%
  rename("species" = "Nom_Scientifique",
         "station" = "Code_Station") %>%
  left_join(metadata) %>%
  select(species, Tot_V_HV, volume_filtered, station) %>%
  # Divide biomass by the volume filtered at each trawl (g.m3)
  mutate(biomass_cpu = (Tot_V_HV / volume_filtered) * 1000) %>%
  select(species, biomass_cpu, station) %>%
  replace(is.na(.), 0) %>%
  group_by(species, station) %>%
  mutate(biomass = sum(biomass_cpu)) %>%
  select(-biomass_cpu) %>%
  distinct() %>%
  tidyr::pivot_wider(names_from = species, values_from = biomass) %>%
  replace(is.na(.), 0) %>%
  arrange(station) %>%
  filter(!station%in%c("H0411","L0731", "L0736")) %>%
  tibble::column_to_rownames(var = "station") %>%
  # Change species names
  rename("Lampanyctus_ater" = "Nannobrachium_atrum") %>%
  rename("Cyclothone_sp" = "Cyclothone") %>%
  rename("Stomias_boa" = "Stomias_boa_boa") %>%
  select(order(colnames(.))) %>%
  as.matrix()

# if we want only presence-absence 
#station_sp <- replace(station_sp, station_sp > 0, 1)

# dist matrix (gower)
sp_dist_fish <- mFD::funct.dist(
  sp_tr         = fish_traits,
  tr_cat        = fish_traits_cat,
  metric        = "gower",
  scale_euclid  = "scale_center",
  ordinal_var   = "classic",
  weight_type   = "equal",
  stop_if_NA    = TRUE)

# Compute functional spaces 
fspaces_quality_fish <- mFD::quality.fspaces(
  sp_dist             = sp_dist_fish,
  maxdim_pcoa         = 10,
  deviation_weighting = "absolute",
  fdist_scaling       = FALSE,
  fdendro             = "average")

# PC coord
sp_faxes_coord_fish <- fspaces_quality_fish$"details_fspaces"$"sp_pc_coord"

# Calculate functional diversity for the observed data ----
obsFD <- mFD::alpha.fd.multidim(
  sp_faxes_coord = sp_faxes_coord_fish[, c("PC1", "PC2", "PC3", "PC4")],
  asb_sp_w = station_sp,
  scaling = TRUE,
  check_input = TRUE,
  details_returned = F
)

obsFD_div <- obsFD$functional_diversity_indices

# Null model ----
# Define the number of replications
nb_rep <- 10

# Initialize a list to store results of random functional diversity calculations for each index
indices_names <- colnames(obsFD_div)
resultsRandomFD <- list()

for (index_name in indices_names) {
  resultsRandomFD[[index_name]] <- matrix(
    NA,
    nrow = nrow(station_sp),
    ncol = nb_rep,
    dimnames = list(rownames(station_sp), paste0("Sim.", 1:nb_rep))
  )
}

# Perform randomization and calculate functional diversity for each replication
for (rep in 1:nb_rep) {
  randomize_mx <- picante::randomizeMatrix(
    samp = station_sp,
    null.model = "frequency", # richness, independentswap, trialswap
    iterations = 10
  )
  
  simFD_cal <- mFD::alpha.fd.multidim(
    sp_faxes_coord = sp_faxes_coord_fish[, c("PC1", "PC2", "PC3", "PC4")],
    asb_sp_w = randomize_mx,
    scaling = TRUE,
    check_input = TRUE,
    details_returned = F
  )
  
  simFD_div <- simFD_cal$functional_diversity_indices
  
  for (index_name in indices_names) {
    simFD_index <- simFD_div[, index_name]
    
    # Ensure that simFD_index has the same length as the number of rows in station_sp
    if(length(simFD_index) == nrow(station_sp)) {
      resultsRandomFD[[index_name]][, rep] <- simFD_index
    } else {
      stop(paste("The length of", index_name, "does not match the number of rows in station_sp"))
    }
  }
}

# Initialize dataframes to store mean, standard deviation, effect size, and standardized effect size
meanNullFD <- data.frame(matrix(NA, nrow = nrow(station_sp), ncol = length(indices_names)))
sdNullFD <- data.frame(matrix(NA, nrow = nrow(station_sp), ncol = length(indices_names)))
ES_FD <- data.frame(matrix(NA, nrow = nrow(station_sp), ncol = length(indices_names)))
SES_FD <- data.frame(matrix(NA, nrow = nrow(station_sp), ncol = length(indices_names)))

# Set column names for the dataframes
colnames(meanNullFD) <- indices_names
colnames(sdNullFD) <- indices_names
colnames(ES_FD) <- indices_names
colnames(SES_FD) <- indices_names

# Calculate statistics for each index
for (index_name in indices_names) {
  # Calculate mean and standard deviation of null model FD values for each index
  meanNullFD[, index_name] <- rowMeans(resultsRandomFD[[index_name]], na.rm = TRUE)
  sdNullFD[, index_name] <- apply(resultsRandomFD[[index_name]], 1, sd, na.rm = TRUE)
  
  # Calculate effect size and standardized effect size for each index
  ES_FD[, index_name] <- obsFD_div[, index_name] - meanNullFD[, index_name]
  SES_FD[, index_name] <- ES_FD[, index_name] / sdNullFD[, index_name]
}

# Combine all results into a single dataframe
results_df <- cbind(
  # obsFD_div,
  # meanNullFD = meanNullFD,
  # sdNullFD = sdNullFD,
  # ES_FD = ES_FD,
  SES_FD = SES_FD
)

# Add row names
rownames(results_df) <- rownames(station_sp)

# Plot  ----
# Output the results dataframe
results_df_plot <- results_df %>%
  tibble::rownames_to_column(var = "station") %>% 
  inner_join(metadata %>% select(station, depth), by = "station") %>%
  mutate(
    depth_layer = case_when(
      between(depth, 0, 174) ~ "Epipelagic",
      between(depth, 175, 699) ~ "Upper mesopelagic",
      between(depth, 700, 999) ~ "Lower mesopelagic",
      between(depth, 1000, 2000) ~ "Bathypelagic"
    )
  ) %>% 
  select(-station) %>%
  tidyr::pivot_longer(!c(depth, depth_layer),
                      values_to = "values",
                      names_to = "indice") %>%
  mutate(indice = stringr::str_replace(indice, "^SES_", "")) %>%
  filter(
    indice %in% c(
      "FD.fric",
      "FD.fdis",
      "FD.fmpd",
      "FD.fnnd",
      "FD.feve",
      "FD.fdiv",
      "FD.fori",
      "FD.fspe"
    )
  )

results_df_plot$depth_layer <- factor(results_df_plot$depth_layer, 
                                      levels = c("Epipelagic", "Upper mesopelagic",
                                                 "Lower mesopelagic", "Bathypelagic"))
results_df_plot$indice <- factor(results_df_plot$indice,
                                 levels = c("FD.fric",
                                            "FD.fdis",
                                            "FD.fdiv",
                                            "FD.feve",
                                            "FD.fori",
                                            "FD.fspe",
                                            "FD.fnnd",
                                            "FD.fmpd"
                                            ))

ggplot(results_df_plot, aes(x = depth_layer, y = values, fill = depth_layer)) +
  facet_wrap(~indice, scales = "free") +
  geom_point(alpha = 0.5, size = 1, position = position_jitter(width = 0.2), aes(col=depth_layer)) +
  geom_boxplot(alpha = 0.1, outlier.shape = NA, width = 0.5, aes(col=depth_layer, fill=depth_layer))+
  scale_color_manual(values = c("#FEA520", "#D62246", "#6255B4", "#3C685A")) +
  scale_fill_manual(values = c("#FEA520", "#D62246", "#6255B4", "#3C685A")) +
  labs(
    x = "",
    y = "Standard Effect Size (SES)"
  ) +
  theme_light() +
  theme(axis.text.x = element_blank(),
        strip.text.x = element_text(
          size = 13,
          face = "bold",
          color = "gray20"
        ),
        strip.background = element_rect(fill = "white"),
        axis.title = element_text(size = 13),
        axis.text = element_text(size = 13))+
  geom_hline(yintercept = 0, linetype = "dashed", color = "black", linewidth = 0.8)+
  guides(col="none", fill="none")

```


# Isotopes data 
- 4 sp manquantes en d15N = _P. coregonoides, E. pelacanoides, H. anomala, S. bathyphilus_

```{r}
#| echo: false
#| label: range_d15n
#| warning: false
#| message: false
#| fig-width: 8
#| fig-height: 8

isotope_data <- utils::read.csv(here::here("data", "isotopes_data.csv"), sep = ";", header = T, dec = ",")

depth_fish_biomass_2 <- rbind(data_biomass_2002_2019, data_biomass_2021, data_biomass_2022)%>%
  as.data.frame()%>%
  rename("species"="Nom_Scientifique",
         "station"="Code_Station") %>%
  left_join(metadata) %>%
  select(species, Tot_V_HV, depth, volume_filtered)%>%
  # divise biomass by the volume filtered at each trawl (g.m3)
  mutate(biomass_cpu=(Tot_V_HV/volume_filtered)*1000)%>%
  select(species, depth, biomass_cpu)%>%
  replace(is.na(.), 0)%>%
  group_by(species, depth)%>%
  mutate(biomass=sum(biomass_cpu))%>%
  select(-c(biomass_cpu))%>%
  distinct()%>%
  tidyr::pivot_wider(names_from = species, values_from = biomass)%>%
  replace(is.na(.), 0)%>%
  tibble::column_to_rownames(var = "depth")%>%
  #change species name
  rename("Lampanyctus_ater"="Nannobrachium_atrum")%>%
  rename("Cyclothone_sp"="Cyclothone")%>%
  rename("Stomias_boa"="Stomias_boa_boa") %>%
  as.matrix()


isotope_data_sum <- isotope_data %>% 
  group_by(species) %>% 
  summarise(sd=sd(d15N),
            mean=mean(d15N)) %>% 
  ungroup() %>%
  mutate(species = reorder(species, mean))
  
# Make a summary data.frame
sp_coord <- as.data.frame(sp_faxes_coord_fish[, 1:4])
sp_coord$species <- rownames(sp_coord)

sp_coord_iso <- sp_coord %>%
  merge(taxonomic_families, by = "species") %>%
  merge(isotope_data, by = "species") %>%
  group_by(species) %>% 
  mutate(mean_d15n=mean(d15N)) %>% 
  distinct() %>% 
  mutate(shape = case_when(
    family == "Myctophidae" ~ "A",
    family == "Platytroctidae" ~ "B",
    TRUE ~ "C"
  ))

ggplot(isotope_data_sum, aes(x = mean, y = species, xmin = mean-sd, xmax = mean+sd)) +
  geom_point() +
  geom_errorbarh(height=.2)+
  theme_light()+
  theme(axis.text = element_text(size = 12))+
  labs(x= expression({delta}^15*N~'\u2030'), y="")+
  guides(col="none")

```

- functional space : colours according to d15N values
```{r}
#| echo: false
#| label: Func_sapce_iso
#| warning: false
#| message: false
#| fig-width: 8
#| fig-height: 6

ggplot(sp_coord_iso, aes(PC1, PC2)) +
  geom_hline(yintercept = 0, linetype = 2) +
  geom_vline(xintercept = 0, linetype = 2) +
  geom_point(aes(color = mean_d15n, shape=shape), size = 3.5) +
  scale_shape_manual(values = c(15,17,19), name = "Taxonomic family",
                     labels = c("Myctophidae", "Platytroctidae", "Other"))+
  scale_color_gradient(low = "#0BA1F0", high = "red")+
  theme_bw() +
  labs (col= expression({delta}^15*N~'\u2030'))+
  theme(aspect.ratio = 1, legend.title = element_text(size = 12), legend.text = element_text(size = 12))

```

- significant relationships between d15n and traits 
```{r}
#| echo: false
#| label: d15N_traits
#| warning: false
#| message: false
#| fig-width: 8
#| fig-height: 6

d15n <- isotope_data_sum %>% 
  select(mean, species) %>% 
  rename(d15N=mean)

trait_d15n_num <- fish_traits %>% 
  as.data.frame() %>% 
  select_if(is.numeric) %>%
  tibble::rownames_to_column(var = "species") %>% 
  inner_join(d15n, by = "species") %>% 
  distinct() %>% 
  select(-species) %>% 
  tidyr::pivot_longer(!d15N, values_to = "values", names_to = "trait") %>% 
  filter(trait%in%c("caudal_throttle_width",
                    "dorsal_fin_insertion",
                    "pectoral_fin_insertion",
                    "pectoral_fin_position"))

ggplot(trait_d15n_num, aes(x=values, y=d15N))+
  facet_wrap(~trait, scales = "free_x")+
  geom_point (alpha=0.4, col="black") + 
  geom_smooth(method=lm, se=T, alpha=0.2, col= alpha("darkblue",0.7)) +
  ggpmisc::stat_poly_eq(formula = y ~ x, 
                        aes(label = paste(..rr.label.., ..p.value.label.. 
                                          , ..n.label..,sep = "*`,`~")),
                        parse = TRUE,
                        size=3.38,
                        vstep = -0.0005)+
  theme_minimal()


```

- categorical traits 

```{r}
#| echo: false
#| label: d15N_traits_cat
#| warning: false
#| message: false
#| fig-width: 9
#| fig-height: 8

trait_d15n_cat <- fish_traits[,17:25]%>% 
  as.data.frame() %>% 
  mutate_all( as.character)%>%
  tibble::rownames_to_column(var = "species") %>% 
  tidyr::pivot_longer(!species, values_to = "values", names_to = "trait") %>% 
  inner_join(d15n, by = "species") %>% 
  distinct() 

ggplot(trait_d15n_cat, aes(x = values, y = d15N)) +
  theme_minimal() +
  facet_wrap(~ trait, scales = "free") +
  geom_point() +
  geom_boxplot() 

```

# Plan 

## __I. Key traits and foraging strategies by depth layer  __

### __Figure 1:__  Lateral-view photographs  

```{r}
#| label: Lateral_view
#| echo: false
#| out-width: 50%

knitr::include_graphics("figures/lateral_heads.png")

```

### __Figure 2:__ Functional spaces 

- At the community level & by depth layer 

- Only PC1-PC2 and PC3-PC4 in appendices? 

```{r}
#| label: function_space_plot
#| echo: false

knitr::include_graphics("figures/PC1_PC2-1.png")
```
```{r}
#| echo: false
#| label: PCOA
#| fig-width: 10
#| fig-height: 8

# Load necessary libraries
library(vegan)

# Perform PCoA
pcoa_results <- cmdscale(sp_dist_fish, eig = TRUE, k = (nrow(fish_traits) - 1))

# Extract scores
scores <- as.data.frame(pcoa_results$points)

# Ensure fish_traits is a data frame
fish_traits <- as.data.frame(fish_traits)

# traits variables
env_fit <- envfit(scores, fish_traits, permutations = 999)

# Plot PCoA results
plot(scores[, 1], scores[, 2],
     xlab = paste0("PCoA 1 (", round(pcoa_results$eig[1] / sum(pcoa_results$eig) * 100, 2), "%)"),
     ylab = paste0("PCoA 2 (", round(pcoa_results$eig[2] / sum(pcoa_results$eig) * 100, 2), "%)"),
     main = "PCoA of Fish Species",
     pch = 19, col = "gray50")

# Add text labels to points
text(scores[, 1], scores[, 2], labels = rownames(fish_traits), pos = 4, cex = 0.7, col = "gray50")

# Add environmental vectors
plot(env_fit, p.max = 0.05, col = "#008E9B")

# Optionally, add a grid
abline(h = 0, v = 0, col = "gray", lty = 2)

```

### __Table 1__: significant traits

- which traits significantly influence each axis?  

- at the community level & by depth layer
```{r}
#| echo: false
#| label: table_significant

fish_tr_faxes <- mFD::traits.faxes.cor(
  sp_tr          = fish_traits, 
  sp_faxes_coord = sp_faxes_coord_fish[ , c("PC1", "PC2", "PC3", "PC4")], 
  plot           = F)

axis_signi <- fish_tr_faxes %>% 
  as.data.frame() %>% 
  filter(p.value>0.05)

htmltools::tagList(DT::datatable(axis_signi))
```

### __Figure 3__: Community-Weighted Mean

```{r}
#| echo: false
#| label: CWM_plot
#| warning: false
#| message: false
#| fig-width: 10
#| fig-height: 8

ggplot(np_bootstrapped_moments_plot, aes(x=depth_layer, y=mean)) +
  geom_boxplot(aes(col=depth_layer, fill=depth_layer), alpha=0.1) +
  scale_fill_manual(values = c("#FEA520","#D62246","#6255B4","#3C685A"))+
  scale_color_manual(values = c("#FEA520","#D62246","#6255B4","#3C685A"))+
  guides(col="none", fill="none")+
  labs(y="Bootstrapped CWM")+
  facet_wrap(~trait, scales = "free")+
  theme_light()+
  theme(axis.text.x = element_blank(), 
        axis.title.x = element_blank(), 
        axis.title.y.left =  element_text(size =14), 
        strip.text = element_text(size =14, face="bold"),  
        legend.title = element_text(size =11),  
        legend.text = element_text(size =11), 
        axis.title.y = element_text(size=11),
        axis.text.y = element_text(size=12),
        strip.background=element_rect(fill="white"),
        strip.text.x = element_text(size = 10, color = "black"))
```



## II. Functional diversity indices 

### __Figure 4__: Standardized Effect Size

- __Trait convergence__ in the epipelagic layer and __trait divergence__ in the bathypelagic layer 

```{r}
#| echo: false
#| label: ses_mfd_plot
#| warning: false
#| message: false
#| fig-width: 8
#| fig-height: 7

results_df_plot <- results_df %>%
  tibble::rownames_to_column(var = "station") %>% 
  inner_join(metadata %>% select(station, depth), by = "station") %>%
  mutate(
    depth_layer = case_when(
      between(depth, 0, 174) ~ "Epipelagic",
      between(depth, 175, 699) ~ "Upper mesopelagic",
      between(depth, 700, 999) ~ "Lower mesopelagic",
      between(depth, 1000, 2000) ~ "Bathypelagic"
    )
  ) %>% 
  select(-station) %>%
  tidyr::pivot_longer(!c(depth, depth_layer),
                      values_to = "values",
                      names_to = "indice") %>%
  mutate(indice = stringr::str_replace(indice, "^SES_", "")) %>%
  filter(
    indice %in% c(
      "FD.fric",
      "FD.fdis",
      "FD.feve",
      "FD.fdiv"
    )
  )

results_df_plot$depth_layer <- factor(results_df_plot$depth_layer, 
                                      levels = c("Epipelagic", "Upper mesopelagic",
                                                 "Lower mesopelagic", "Bathypelagic"))
results_df_plot$indice <- factor(results_df_plot$indice,
                                 levels = c("FD.fric",
                                            "FD.fdis",
                                            "FD.fdiv",
                                            "FD.feve"
                                            ))

ggplot(results_df_plot, aes(x = depth_layer, y = values, fill = depth_layer)) +
  facet_wrap(~indice, scales = "free") +
  geom_point(alpha = 0.5, size = 1, position = position_jitter(width = 0.2), aes(col=depth_layer)) +
  geom_boxplot(alpha = 0.1, outlier.shape = NA, width = 0.5, aes(col=depth_layer, fill=depth_layer))+
  scale_color_manual(values = c("#FEA520", "#D62246", "#6255B4", "#3C685A")) +
  scale_fill_manual(values = c("#FEA520", "#D62246", "#6255B4", "#3C685A")) +
  labs(
    x = "",
    y = "Standard Effect Size (SES)"
  ) +
  theme_light() +
  theme(axis.text.x = element_blank(),
        strip.text.x = element_text(
          size = 13,
          face = "bold",
          color = "gray20"
        ),
        strip.background = element_rect(fill = "white"),
        axis.title = element_text(size = 13),
        axis.text = element_text(size = 13))+
  geom_hline(yintercept = 0, linetype = "dashed", color = "black", linewidth = 0.8)+
  guides(col="none", fill="none")

ggsave("SES_indices.png", path = "figures/additional_analyses", dpi = 700, height = 6, width = 9)

```

## III. Functional rarity

### __Figure 5__: Uniqueness-geographical restrectiveness
```{r}
#| label: uniqueness_fig
#| echo: false
#| fig-width: 9
#| fig-height: 9

ri <- funrar::restrictedness(depth_fish_biomass_2)

sp_ui <- funrar::uniqueness(
  pres_matrix = depth_fish_biomass,
  as.matrix(sp_dist_fish)
)

sp_ri_ui <- sp_ui %>% 
  inner_join(ri) %>% 
  inner_join(taxonomic_families) %>% 
  mutate(species= gsub("_"," ",species))

stat <- sp_ri_ui %>%  
  summarise(med_ui = median(Ui),
            med_ri =median(Ri),
            mean_ui = mean(Ui),
            mean_ri = mean(Ri)) 

ggplot(sp_ri_ui, aes(Ri,Ui))+
  geom_point(size = 2.7, aes(shape=order))+
  ggrepel::geom_text_repel(aes(label = species), col="grey70", max.overlaps=3, size=4.5)+
  scale_shape_manual(values = c(8, 16, 7, 17, 19, 15, 3, 25))+
  labs(y = "Functional Uniqueness", x = "Geographical Restrictedness", shape="Taxonomic order")+
  theme_bw()+
  geom_hline(yintercept = stat$mean_ui, linetype = "dashed", color = "black", linewidth = 0.8)+
  geom_vline(xintercept = stat$mean_ri, linetype = "dashed", color = "black", linewidth = 0.8)+
  theme(aspect.ratio = 1,
        axis.title = element_text(size=15),
        axis.text = element_text(size=14),
        legend.title = element_text(size=15),
        legend.text = element_text(size=14))

ggsave("Uniqueness_Ri.png", path = "figures/additional_analyses", dpi = 700, height = 8, width = 10)
```
