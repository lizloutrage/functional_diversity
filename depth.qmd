---
title: "depth"
author: "Liz Loutrage"
format: 
  html:
    self-contained: true
    code-fold: true
editor: source
keep-md: true
execute:
  warning: false
  message : false
toc: true
toc-title: Sections
toc-location: left
page-layout: full
theme: yeti
fontsize: medium
---

# Data preparation
```{r}
#| echo: true
#| label: morpho_data
#| warning: false

library(dplyr)
library(ggplot2)

morphometric_data <- utils::read.csv(here::here("data", "morphometric_data.csv"), sep = ";", header = T, dec = ".")

morpho_data <- morphometric_data %>%
  select(-c(variable_abbreviation, variable_unit)) %>%
  t() %>%
  as.data.frame() %>%
  janitor::row_to_names(row_number = 1) %>%
  `rownames<-`(NULL)%>%
  # delete for now (n=1)
  filter(species!= "Diaphus_sp")

# replace empty value by NA 
morpho_data[morpho_data ==""] <- NA

# Numeric variables
morpho_data[, 4:23] <- sapply(morpho_data[, 4:23], as.numeric)
```

__Data summary__
```{r}
#| echo: true
#| label: summary_data
#| warning: false

morpho_data_summary <-morpho_data %>%
  group_by(species) %>%
  count(species)

htmltools::tagList(DT::datatable(morpho_data_summary))
```

## Missing data 
The operculum width was the variable with the highest number of missing data (n = 30). This represents 4% of the data 

__2 species with only NAs for an entire trait:__

+ _Eurpharynx pelecanoides_ : 7 traits
+ _Melanostigma atlanticum_ : 2 traits

```{r}
#| echo: false
#| label: found_na
#| warning: false
#| message: false

# number of NA for each trait for each species
n_missing_data <- morpho_data %>%
  select(-c(weight, individual_code, station)) %>%
  group_by(species) %>%
  summarise_all(funs(sum(is.na(.)))) %>%
  tidyr::pivot_longer(!species, names_to = "traits", values_to = "n_na")

# number of individuals by species
n_ind <- morpho_data %>%
  select(-c(weight, individual_code, station)) %>%
  group_by(species) %>%
  summarise(n = n())

missing_data <- n_missing_data %>%
  left_join(n_ind) %>%
  #  # if sum = 0 then this species only has NAs for this trait
  mutate(found_na = n - n_na)
```


### data imputation  
- mice algorithm: n imputation = 5, n iterations = 50
- plot comparison for Operculum Width
```{r}
#| echo: true
#| label: imputation_data
#| warning: false
#| message: false
#| fig-width: 13
#| fig-height: 9

#select numeric variables for imputation 
original_data <- morpho_data %>%
  select(1:23)

imputation <-
  mice::mice(
    original_data,
    m = 5,
    maxit = 50,
    printFlag = F
  )

imputed_data <- mice::complete(imputation)

comparison <- tibble::tibble(species = original_data$species,
                             standard_length = original_data$standard_length,
                             Original = original_data$operculum_width,
                             Imputed = imputed_data$operculum_width) %>%
  arrange(species, standard_length)

ggplot(comparison, aes(standard_length, Imputed, col = is.na(Original))) +
  geom_point(size = 2, alpha=0.8) +
  facet_wrap(~species, scales = "free") +
  labs(col = "Imputed?") +
  scale_color_manual(values = c("grey60", "firebrick2")) +
  theme_bw()
```

__Measures density distribution__
```{r}
#| echo: true
#| label: density_plot_measures
#| warning: false
#| message: false
#| fig-width: 12
#| fig-height: 9

density_plot <- imputed_data  %>%
  select(-c(individual_code, station, weight)) %>% 
  tidyr::pivot_longer(!species, names_to = "traits", values_to = "values")

ggplot(density_plot , aes(values)) +
  geom_histogram(bins = 10,
                 color = "darkgrey",
                 fill = "lightgray") +
  facet_wrap(~ traits, scales = "free") +
  theme_minimal()+
  theme(strip.text.x = element_text(size = 8, face = "bold"))

```

## Species * traits
### calctulate functional traits 
```{r}
#| echo: true
#| label: functional_traits
#| warning: false
#| message: false

# calculate functional numeric traits
numeric_traits <- imputed_data %>%
  na.omit() %>%
  select(-individual_code) %>%
  mutate(
    eye_size = eye_diameter / head_depth,
    orbital_length = eye_diameter / standard_length,
    oral_gap_surface = mouth_width * mouth_depth / body_width * body_depth,
    oral_gape_shape = mouth_depth / mouth_width,
    oral_gape_position = distance_upper_jaws_bottom_head / head_depth,
    lower_jaw_length = lower_jaw_length / standard_length,
    head_length = head_length / standard_length,
    body_depth = body_depth / standard_length,
    pectoral_fin_position = distance_pectoral_bottom_body / body_depth_pectoral_insertion,
    pectoral_fin_insertion = prepectoral_length / standard_length,
    transversal_shape = body_depth / body_width,
    dorsal_fin_insertion = predorsal_length / standard_length,
    eye_position = eye_height / head_depth,
    operculum_volume = operculum_depth / operculum_width
  ) %>%
  select(
    species,
    eye_size,
    orbital_length,
    oral_gap_surface,
    oral_gape_shape,
    oral_gape_position,
    lower_jaw_length,
    operculum_width,
    head_length,
    body_depth,
    pectoral_fin_position,
    pectoral_fin_insertion,
    transversal_shape,
    caudal_peduncle_min_depth,
    dorsal_fin_insertion,
    eye_position,
    operculum_volume
  ) %>%
  group_by(species) %>%
  summarise(across(everything(), mean, na.rm = TRUE)) %>%
  arrange(species)

# categorical traits for species without NA
cat_morpho <- morpho_data %>%
  select(
    species,
    photophores_ventral_position ,
    gland_head,
    chin_barbel,
    front_barbel,
    small_teeth,
    large_teeth,
    fang_teeth,
    retractile_teeth,
    internal_teeth,
    gill_raker_types,
    oral_gape_axis
  ) %>%
    na.omit() %>%
  distinct() %>%
  arrange(species)

# combined the two data frames
fish_traits <- numeric_traits %>%
  inner_join(cat_morpho, by = "species") %>%
  arrange(species) %>% 
  tibble::column_to_rownames("species")%>%
  # assign trait type 
  # as.factor for qualitative traits
  mutate_if(is.character, as.factor)%>%
  # as.ordered for ordered variables
  mutate_at(c("gill_raker_types", "oral_gape_axis"), as.ordered)

```

__Traits density distribution__
```{r}
#| echo: true
#| label: density_plot_traits
#| warning: false
#| message: false
#| fig-width: 12
#| fig-height: 9

density_plot_traits <- fish_traits[,1:16] %>% 
    tibble::rownames_to_column(var="species") %>% 
    tidyr::pivot_longer(!species, names_to = "traits", values_to = "values")

ggplot(density_plot_traits , aes(values)) +
  geom_histogram(bins = 10,
                 color = "darkgrey",
                 fill = "lightgray") +
  facet_wrap(~ traits, scales = "free") +
  theme_minimal()+
  theme(strip.text.x = element_text(size = 11, face = "bold"))
```


```{r}
#| echo: true
#| label: sp_traits
#| warning: false
#| message: false

## Display the table ----
htmltools::tagList(DT::datatable(fish_traits))
```

__traits correlation__
```{r}
#| echo: true
#| label: traits_correlation
#| warning: false
#| message: false
#| fig-width: 8
#| fig-height: 10

M <-cor(numeric_traits[, c(-1)])

ggcorrplot::ggcorrplot(M, hc.order = TRUE, type = "lower",
           lab = TRUE, tl.cex = 9)

```



## Species * assemblages matrix
```{r}
#| echo: true
#| label: sp_depth_mt
#| warning: false

# list of species 
sp_names <- c(rownames(fish_traits), "Nannobrachium_atrum", "Cyclothone", "Stomias_boa_boa")

# Metadata
metadata <-  utils::read.csv(here::here("data", "metadata.csv"), sep = ";", header = T, dec = ".")%>%
  # calculation of standardized biomass values (vertical  trawl opening * horizontal trawl opening * distance traveled)  
  mutate(volume_filtered = 24*58*distance)

# species biomass x depth  matrix 2002-2019 ----
data_biomass_2002_2019 <- utils::read.csv(here::here("data", "data_evhoe_catch_2002_2019.csv"), sep = ";", header = T, dec = ".")%>%
  replace(is.na(.), 0)%>%
  as.data.frame()%>%
  rename("species"="Code_Station")%>%
  mutate(species= gsub(" ","_", species))%>%
  filter(species%in%sp_names)%>%
  t()%>%
  as.data.frame()%>%
  janitor::row_to_names(row_number = 1)%>%
  mutate_if(is.character, as.numeric)%>%
  tibble::rownames_to_column("Code_Station")%>%
  filter(!Code_Station=="H0472")%>%
  tidyr::pivot_longer(!Code_Station, names_to = "species", values_to = "Tot_V_HV")%>%
  rename("Nom_Scientifique"="species")

# species biomass x depth  matrix 2021 ----
data_biomass_2021 <- utils::read.csv(here::here("data", "data_evhoe_catch_2021.csv"), sep = ";", header = T, dec = ".")%>%
  select(Nom_Scientifique, Tot_V_HV, Code_Station)%>%
  distinct()%>%
  mutate(Nom_Scientifique= gsub(" ","_",Nom_Scientifique))%>%
  filter(Nom_Scientifique%in%sp_names)

# species biomass x depth  matrix 2022 ----
data_biomass_2022 <- utils::read.csv(here::here("data", "data_evhoe_catch_2022.csv"), sep = ";", header = T, dec = ".")%>%
  select(Nom_Scientifique, Tot_V_HV, Code_Station)%>%
  distinct()%>%
  mutate(Nom_Scientifique= gsub(" ","_",Nom_Scientifique))%>%
  filter(Nom_Scientifique%in%sp_names)

depth_fish_biomass <- rbind(data_biomass_2002_2019, data_biomass_2021, data_biomass_2022)%>%
  as.data.frame()%>%
  rename("species"="Nom_Scientifique",
         "station"="Code_Station") %>%  
  left_join(metadata) %>% 
  select(species, Tot_V_HV, depth, volume_filtered)%>%
  # divise biomass by the volume filtered at each trawl (g.m3)
  mutate(biomass_cpu=(Tot_V_HV/volume_filtered)*1000)%>%
  select(species, depth, biomass_cpu)%>%  
  # add column with depth layer
  replace(is.na(.), 0)%>%
  group_by(species, depth)%>%
  mutate(biomass=sum(biomass_cpu))%>%
  select(-c(biomass_cpu))%>%
  distinct()%>%
  tidyr::pivot_wider(names_from = species, values_from = biomass)%>%
  replace(is.na(.), 0)%>%
  tibble::column_to_rownames(var = "depth")%>% 
  #change species name
  rename("Lampanyctus_ater"="Nannobrachium_atrum")%>%
  rename("Cyclothone_sp"="Cyclothone")%>%
  rename("Stomias_boa"="Stomias_boa_boa") %>% 
  as.matrix()

```

- __assemblages__ = depth layers 
- __biomass data__ = all EVHOE data 2002-2022 (in m^3)
```{r}
#| echo: true
#| label: depth_fish_biomass
#| warning: false
#| message: false

htmltools::tagList(DT::datatable(depth_fish_biomass))
```

### Species depth distribution 
```{r}
#| echo: true
#| label: density_depth_distribution
#| warning: false
#| message: false
#| fig-width: 11
#| fig-height: 7

depth_distribution <- rbind(data_biomass_2002_2019, data_biomass_2021, data_biomass_2022)%>%
  as.data.frame()%>%  
  rename("station"="Code_Station")%>%
  left_join(metadata)%>%
  rename("species"="Nom_Scientifique")%>% 
  select(-c(station))%>%
  distinct()%>%
  filter(Tot_V_HV>0)%>%
  group_by(species)%>%
  mutate(biomass_tot = sum(Tot_V_HV))%>%
  ungroup()%>%
  group_by(species, depth)%>%
  mutate(biomass_depth = sum(Tot_V_HV))%>%
  select(species, biomass_depth, biomass_tot, depth)%>%
  distinct()%>%
  group_by(species, depth)%>%
  mutate(biomass_rel=biomass_depth/biomass_tot*100)%>%
  select(species, depth, biomass_rel)%>%
  mutate(biomass = as.integer(biomass_rel))%>%
  select(-biomass_rel)%>%
  tidyr::uncount(biomass)

# Order in function of median depth
depth_distribution$species = with(depth_distribution, reorder(species, depth, median))  

ggplot(depth_distribution,
       aes(x = depth, y = species, group = species)) + 
  ggridges::stat_density_ridges(geom="density_ridges", scale=1.5, alpha=0.6, rel_min_height = 0.005,
                                quantile_lines = TRUE, quantiles = 2, size = 0.4, col= "gray30")+
  theme_bw()+
  ylab(label = "")+ xlab("Immersion depth (m)")+
  theme(axis.text.y = element_text(size=13),
        axis.text.x = element_text(face="italic", size=10, angle=80,vjust = 0.5, hjust=0),
        axis.title.x = element_text(size=13),
        axis.title.y = element_text(size=13))+
  xlim(0, 2000)+
  scale_y_discrete(position = "right")+
  scale_x_reverse()+
  coord_flip()+
  guides(fill="none", col="none" ,alpha="none")

ggsave("depth_distribution.png", path = "figures", height = 8, width = 12)

```


## Traits types

The **first column** contains **traits name**. The **second column** contains
**traits type** following this code:

* **N**: nominal trait (factor variable)
* **O**: ordinal traits (ordered variable)
* **Q**: quantitative traits (numeric values)

* 1/3 of the traits are nominal (traits related to teeth and photophores), need to give them different weights so as not to overestimate functional diversity? 
```{r}
#| echo: true
#| label: fish_traits_cat
#| warning: false
#| message: false

fish_traits_cat <- utils::read.csv(here::here("data", "fish_traits_cat.csv"), sep = ";", header = T, dec = ".")
htmltools::tagList(DT::datatable(fish_traits_cat))
```
# 1. CWM 
__Community Weighted Mean__ : somme de l'abondance relative d'une espèce x valeur du trait

+ trait quantittatif : valeur moyenne du trait si on prend un individu au hasard dans l'assemblage 

+ trait catégoriel : proportion des espèces possédant ce trait, une valeur élevée peut indiquer soit qu'un grand nombre possèdent se trait ou que l'espèce avec la plus forte abondance relative possède ce trait 

+ données centrées-réduites 

```{r}
#| echo: true
#| label: CWM
#| warning: false
#| message: false

# spxcom.matrix ----
spxcom.matrix <-  depth_fish_biomass %>% 
  t() %>% 
  as.data.frame() %>% 
  relocate("Epipelagic", "Upper mesopelagic", "Lower mesopelagic","Bathypelagic" ) %>% 
  tibble::rownames_to_column("species") %>% 
  arrange(species) %>% 
  tibble::column_to_rownames("species") %>% 
  as.matrix()

# spxtraits.matrix ----
spxtraits.matrix <- fish_traits %>%
  mutate(across(17:25, ~ case_when(. == "P" ~ 1, 
                                   . == "A" ~ 0, 
                                   TRUE ~ as.numeric(.))),
         across(26, ~ case_when(. == "A" ~ 1, 
                                . == "B" ~ 2, 
                                . == "C" ~ 3, 
                                TRUE ~ as.numeric(.)))) %>% 
  select(-c(gill_raker_types, oral_gape_axis)) %>% 
  # center and scale 
  mutate(across(everything(), scale)) %>% 
  as.matrix()

# Remove the "[,1]" suffix from column names
names(spxtraits.matrix) <- gsub("[,1]", "", names(spxtraits.matrix))

#check rownames
#rownames(spxtraits.matrix) == rownames(spxcom.matrix)

result_CWM <- FD::functcomp(spxtraits.matrix, t(spxcom.matrix)) 
#FD::functcomp(spxtraits.matrix, t(spxcom.matrix), CWM.type = "all")

```

```{r}
#| echo: true
#| label: CWM_plot
#| warning: false
#| message: false
#| fig-width: 14
#| fig-height: 8

#  Calculate Total biomass
total_biomass <- colSums(spxcom.matrix)

#  Calculate Relative biomass
sp_rel_biomass <- t(spxcom.matrix) / total_biomass

# Transpose the Relative biomass Matrix for Display
t_sp_rel_biomass <- t(sp_rel_biomass)

total_sum <- colSums(t(sp_rel_biomass))

# Initialize an empty data frame to store results
CWM_df <- data.frame(
  depth = character(),
  trait = character(),
  total_sum = numeric(),
  weighted_mean = numeric(),
  SD = numeric(),
  stringsAsFactors = FALSE
)

# Loop through each trait
for (trait in colnames(spxtraits.matrix)) {
  # Calculate the weighted sum for the current trait
  weighted_sum <- colSums(t_sp_rel_biomass * spxtraits.matrix[, trait])
  
  # Calculate the standard deviation for the current trait within each depth
  sd_values <- apply(t_sp_rel_biomass, 2, sd)
  
  # Create a data frame for the current trait
  trait_df <- data.frame(
    depth = colnames(t_sp_rel_biomass),
    trait = trait,
    total_sum = total_sum,
    weighted_mean = weighted_sum,
    SD = sd_values
  )
  
  # Append results to the main data frame
  CWM_df <- rbind(CWM_df, trait_df)
}

CWM_df$depth <- factor(CWM_df$depth, 
                             levels = c("Epipelagic", "Upper mesopelagic", "Lower mesopelagic", "Bathypelagic"))

ggplot(CWM_df, aes(x = depth, y = weighted_mean, group = depth, color = depth)) +
  geom_point(position = position_dodge(width = 0.75), size = 3) +
  facet_wrap(~trait, scales = "free") + 
  geom_errorbar(aes(ymin = weighted_mean - SD, ymax = weighted_mean + SD), position = position_dodge(width = 0.75), width = 0.2) +
  paletteer::scale_color_paletteer_d("ggsci::category20c_d3")+
  labs(x = "",
       y = "CMW") +
  theme_minimal()+
  theme(axis.text.x = element_blank(), 
        axis.title.x = element_blank(), 
        strip.text = element_text(size = 11, face="bold"),  
        legend.title = element_text(size = 12),  
        legend.text = element_text(size = 12), 
        axis.title.y = element_text(size=13))

```


# 2. Build a functional space using the mFD package

## 2.1 Compute data summaries  

```{r}
#| echo: true
#| label: sum_assem_sp
#| warning: false
#| message: false

## Summary of the assemblages * species data.frame ----
asb_sp_fish_summ <- mFD::asb.sp.summary(asb_sp_w = depth_fish_biomass)
asb_sp_fish_occ  <- asb_sp_fish_summ$"asb_sp_occ"

htmltools::tagList(DT::datatable(asb_sp_fish_occ))
```

## 2.2 Computing distances between species based on functional traits
- We have non-continuous traits so we use the __Gower distance__ _(metric = "gower")_ as this method allows traits weighting.
- __scale_euclid__ = TRUE
```{r}
#| echo: true
#| label: dist_fish
#| warning: false
#| message: false

sp_dist_fish <- mFD::funct.dist(
  sp_tr         = fish_traits,
  tr_cat        = fish_traits_cat,
  metric        = "gower",
  scale_euclid  = "scale_center",
  ordinal_var   = "classic",
  weight_type   = "equal",
  stop_if_NA    = TRUE)

## Output of the function mFD::funct.dist() ----
#round(sp_dist_fish, 3)

```

## 2.3 Building functional spaces and chosing the best one
### 2.3.1 Computing several multimensional functional spaces and assessing their quality

- mFD evaluates the quality of PCoA-based multidimensional spaces according to the deviation between trait-based distances and distances in the functional space (extension of Maire et al. (2015) framework). 

```{r}
#| echo: true
#| label: fspaces_quality_fish
#| warning: false
#| message: false

fspaces_quality_fish <- mFD::quality.fspaces(
  sp_dist             = sp_dist_fish,
  maxdim_pcoa         = 10,
  deviation_weighting = "absolute",
  fdist_scaling       = FALSE,
  fdendro             = "average")

## Quality metrics of functional spaces ----
round(fspaces_quality_fish$"quality_fspaces", 3)

```
The space with the best quality has the lowest quality metric. 5-D space good ?

### 2.3.2 Illustrating the quality of the functional spaces

```{r}
#| echo: true
#| label: fspaces_quality_plot
#| warning: false
#| message: false
#| fig-width: 13
#| fig-height: 10

mFD::quality.fspaces.plot(
  fspaces_quality            = fspaces_quality_fish,
  quality_metric             = "mad",
  fspaces_plot               = c("tree_average", "pcoa_2d", "pcoa_3d", 
                                 "pcoa_4d", "pcoa_5d", "pcoa_6d"),
  name_file                  = NULL,
  range_dist                 = NULL,
  range_dev                  = NULL,
  range_qdev                 = NULL,
  gradient_deviation         = c(neg = "darkblue", nul = "grey80", pos = "darkred"),
  gradient_deviation_quality = c(low = "yellow", high = "red"),
  x_lab                      = "Trait-based distance")
```

This function generates a figure with three panels (in rows) for each selected functional space (in columns). Each column represents a functional space, the value of the quality metric is written on the top of each column. The x-axis of all panels represents trait-based distances. The y-axis is different for each row:

+ on the first (top) row, the y-axis represents species functional distances in the multidimensional space. Thus, the closer species are to the 1:1 line, the better distances in the functional space fit trait-based ones.
+ on the second row, the y-axis shows the raw deviation of species distances in the functional space compared to trait-based distances. Thus, the raw deviation reflects the distance to the horizontal line.
+ on the third row (bottom), the y-axis shows the absolute or squared deviation of the (“scaled”) distance in the functional space. It is the deviation that is taken into account for computing the quality metric.

### 2.3.3 Testing the correlation between functional axes and traits
```{r}
#| echo: true
#| label: test_correlation
#| warning: false
#| message: false
#| fig-width: 14
#| fig-height: 9

sp_faxes_coord_fish <- fspaces_quality_fish$"details_fspaces"$"sp_pc_coord"

# As we have 27 traits we have to split the df to see correlation between functional axes and traits 
# first set ----
fish_traits_1 <- fish_traits%>%
  select(1:9)

fish_tr_faxes <- mFD::traits.faxes.cor(
  sp_tr          = fish_traits_1, 
  sp_faxes_coord = sp_faxes_coord_fish[ , c("PC1", "PC2", "PC3", "PC4")], 
  plot           = T)

## Print traits with significant effect ----
fish_tr_faxes$"tr_faxes_stat"[which(fish_tr_faxes$"tr_faxes_stat"$"p.value" < 0.05), ]

## Plot ----
fish_tr_faxes$"tr_faxes_plot"
```

```{r}
#| echo: true
#| label: test_correlation_2
#| warning: false
#| message: false
#| fig-width: 14
#| fig-height: 9

# second set ----
fish_traits_2 <- fish_traits%>%
  select(10:18)

fish_tr_faxes_2 <- mFD::traits.faxes.cor(
  sp_tr          = fish_traits_2, 
  sp_faxes_coord = sp_faxes_coord_fish[ , c("PC1", "PC2", "PC3", "PC4")], 
  plot           = T)

## Print traits with significant effect ----
fish_tr_faxes_2$"tr_faxes_stat"[which(fish_tr_faxes_2$"tr_faxes_stat"$"p.value" < 0.05), ]

## Plot ----
fish_tr_faxes_2$"tr_faxes_plot"
```


```{r}
#| echo: true
#| label: test_correlation_3
#| warning: false
#| message: false
#| fig-width: 14
#| fig-height: 9

# third set ----
fish_traits_3 <- fish_traits%>%
  select(19:27)

fish_tr_faxes_3 <- mFD::traits.faxes.cor(
  sp_tr          = fish_traits_3, 
  sp_faxes_coord = sp_faxes_coord_fish[ , c("PC1", "PC2", "PC3", "PC4")], 
  plot           = T)

## Print traits with significant effect ----
fish_tr_faxes_3$"tr_faxes_stat"[which(fish_tr_faxes_3$"tr_faxes_stat"$"p.value" < 0.05), ]

## Plot ----
fish_tr_faxes_3$"tr_faxes_plot"

```


__Summary of traits with a significant effect__

```{r}
#| echo: true
#| label: traits_effect_list
#| warning: false
#| message: false

sp_faxes_coord_fish <- fspaces_quality_fish$"details_fspaces"$"sp_pc_coord"

fish_tr_faxes <- mFD::traits.faxes.cor(
  sp_tr          = fish_traits, 
  sp_faxes_coord = sp_faxes_coord_fish[ , c("PC1", "PC2", "PC3", "PC4")], 
  plot           = F)

## Print traits with significant effect ----
traits_effect <- fish_tr_faxes[which(fish_tr_faxes$p.value< 0.05),] %>% 
  as.data.frame() %>% 
  arrange(axis, desc(value))

htmltools::tagList(DT::datatable(traits_effect))

```


## 2.4 Plotting the selected functional space and position of species
```{r}
#| echo: true
#| label: plot_functional_space
#| warning: false
#| message: false
#| fig-width: 8
#| fig-height: 8

sp_faxes_coord_fish <- fspaces_quality_fish$"details_fspaces"$"sp_pc_coord"

big_plot <- mFD::funct.space.plot(
  sp_faxes_coord  = sp_faxes_coord_fish[ , c("PC1", "PC2", "PC3", "PC4")],
  faxes           = c("PC1", "PC2", "PC3", "PC4"),
  name_file       = NULL,
  faxes_nm        = NULL,
  range_faxes     = c(NA, NA),
  plot_ch         = TRUE,
  shape_pool      = 20,
  size_pool = 2,
  size_vert = 1.5,
  color_vert      = "blueviolet",
  fill_vert       = "blueviolet",
  color_pool = "#00AB90",
  plot_vertices   = TRUE,
  check_input     = TRUE)

big_plot$"patchwork"
```

```{r}
#| echo: true
#| label: plots_sp_vertices
#| warning: false
#| message: false

sp_names <- rownames(fish_traits)

sp_faxes_coord_fish <- fspaces_quality_fish$"details_fspaces"$"sp_pc_coord"

# PC1 ----
big_plot_PC1 <- mFD::funct.space.plot(
  sp_faxes_coord  = sp_faxes_coord_fish[ , c("PC1", "PC2", "PC3", "PC4")],
  faxes           = c("PC1", "PC2", "PC3", "PC4"),
  name_file       = NULL,
  faxes_nm        = NULL,
  range_faxes     = c(NA, NA),
  plot_ch         = TRUE,
  shape_pool      = 20,
  size_pool = 3,
  size_vert = 2,
  color_vert      = "blueviolet",
  fill_vert       = "blueviolet",
  color_pool = "#00AB90",
  nm_fontface = "bold",
  nm_size = 2.5 ,
  plot_vertices   = TRUE,
  plot_sp_nm      = c("Benthosema_glaciale", "Malacosteus_niger", 
                      "Argyropelecus_olfersii", "Melanostomias_bartonbeani"),
  check_input     = TRUE)

#big_plot_PC1$PC1_PC2


# PC2 ----
big_plot_PC2 <- mFD::funct.space.plot(
  sp_faxes_coord  = sp_faxes_coord_fish[ , c("PC1", "PC2", "PC3", "PC4")],
  faxes           = c("PC1", "PC2", "PC3", "PC4"),
  name_file       = NULL,
  faxes_nm        = NULL,
  range_faxes     = c(NA, NA),
  plot_ch         = TRUE,
  shape_pool      = 20,
  size_pool = 3,
  size_vert = 2,
  color_vert      = "blueviolet",
  fill_vert       = "blueviolet",
  color_pool = "#00AB90",
  nm_fontface = "bold",
  nm_size = 2.5 ,
  plot_vertices   = TRUE,
  plot_sp_nm      = c("Melanostigma_atlanticum", "Anoplogaster_cornuta", 
                      "Argyropelecus_olfersii", "Derichthys_serpentinus"),
  check_input     = TRUE)

#big_plot_PC2$PC2_PC3

# PC3 ----
big_plot_PC3 <- mFD::funct.space.plot(
  sp_faxes_coord  = sp_faxes_coord_fish[ , c("PC1", "PC2", "PC3", "PC4")],
  faxes           = c("PC1", "PC2", "PC3", "PC4"),
  name_file       = NULL,
  faxes_nm        = NULL,
  range_faxes     = c(NA, NA),
  plot_ch         = TRUE,
  shape_pool      = 20,
  size_pool = 3,
  size_vert = 2,
  color_vert      = "blueviolet",
  fill_vert       = "blueviolet",
  color_pool = "#00AB90",
  nm_fontface = "bold",
  nm_size = 2.5 ,
  plot_vertices   = TRUE,
  plot_sp_nm      = c("Paralepis_coregonoides", "Arctozenus_risso", 
                      "Argyropelecus_hemigymnus", "Argyropelecus_olfersii"),
  check_input     = TRUE)

#big_plot_PC3$PC3_PC4

# PC4 ----
big_plot_PC4 <- mFD::funct.space.plot(
  sp_faxes_coord  = sp_faxes_coord_fish[ , c("PC1", "PC2", "PC3", "PC4")],
  faxes           = c("PC1", "PC2", "PC3", "PC4"),
  name_file       = NULL,
  faxes_nm        = NULL,
  range_faxes     = c(NA, NA),
  plot_ch         = TRUE,
  shape_pool      = 20,
  size_pool = 3,
  size_vert = 2,
  color_vert      = "blueviolet",
  fill_vert       = "blueviolet",
  color_pool = "#00AB90",
  nm_fontface = "bold",
  nm_size = 2.5 ,
  plot_vertices   = TRUE,
  plot_sp_nm      = c("Stomias_boa", "Evermannella_balbo",
                      "Derichthys_serpentinus", "Paralepis_coregonoides"),
  check_input     = TRUE)

#big_plot_PC4$PC2_PC4
```

![PCoA](figures/PCoA.png)


# 3. Computing and plotting FD indices using the mFD package

## 3.1 Computing and plotting alpha FD indices

```{r}
#| echo: true
#| label: compute_alpha_FD
#| warning: false
#| message: false

alpha_fd_indices_fish <- mFD::alpha.fd.multidim(
  sp_faxes_coord   = sp_faxes_coord_fish[ , c("PC1", "PC2")],
  asb_sp_w         = depth_fish_biomass,
  ind_vect         = c("fdis", "fric", "fdiv", 
                       "fspe", "fide", "feve"),
  scaling          = TRUE,
  check_input      = TRUE,
  details_returned = TRUE)

```

The function has two main outputs:

+ a data.frame gathering indices values in each assemblage (for FIde values, there are as many columns as there are axes to the studied functional space).

```{r}
#| echo: true
#| label: fd_ind_values_fish
#| warning: false
#| message: false

fd_ind_values_fish <- alpha_fd_indices_fish$"functional_diversity_indices"
htmltools::tagList(DT::datatable(round(fd_ind_values_fish, 3)))
```

```{r}
#| echo: true
#| label: barplot_indices
#| warning: false
#| message: false
#| fig-width: 10
#| fig-height: 6

fd_ind_values_fish_df <- as.data.frame(fd_ind_values_fish) %>% 
  tibble::rownames_to_column(var = "depth") %>% 
  tidyr::pivot_longer(!depth, names_to = "indices", values_to = "values" )

fd_ind_values_fish_df$depth <- factor(fd_ind_values_fish_df$depth, 
                             levels = c("Epipelagic", "Upper mesopelagic", "Lower mesopelagic", "Bathypelagic"))

ggplot(fd_ind_values_fish_df , aes(x=depth, y=values, fill=depth)) +
  paletteer::scale_fill_paletteer_d("ggsci::category20c_d3")+
  geom_bar(stat="identity", position=position_dodge())+
  facet_wrap(~indices, scales = "free")+
  theme_minimal()+
  theme(axis.text.x = element_blank(), 
        axis.title.x = element_blank(), 
        strip.text = element_text(face="bold"))

```


+ a details list of data.frames and lists gathering information such as coordinates of centroids, distances and identity of the nearest neighbour, distances to the centroid, etc. The user does not have to directly use it but it will be useful if FD indices are then plotted. It can be retrieved through:

```{r}
details_list_fish <- alpha_fd_indices_fish$"details"
```

```{r}
#| echo: true
#| label: plots_alpha
#| warning: false
#| message: false

plots_alpha <- mFD::alpha.multidim.plot(
  output_alpha_fd_multidim = alpha_fd_indices_fish,
  plot_asb_nm              = c("Epipelagic", "Bathypelagic"),
  ind_nm                   = c("fdis", "fric", "fdiv", 
                              "fspe", "fide", "feve"),
  faxes                    = NULL,
  faxes_nm                 = NULL,
  range_faxes              = c(NA, NA),
  plot_sp_nm               = NULL,
  save_file                = FALSE,
  check_input              = TRUE) 
```

### __FRic Functional Richness__

- the proportion of functional space filled by species of the studied assemblage, i.e. the volume inside the convex-hull shaping species. To compute FRic the number of species must be at least higher than the number of functional axis + 1.

```{r}
#| echo: true
#| label: plot_FRic_complete
#| warning: false
#| message: false
#| fig-width: 12
#| fig-height: 8

## Compute the range of functional axes:
range_sp_coord  <- range(sp_faxes_coord_fish)

## Based on the range of species coordinates values, compute a nice range ...
## ... for functional axes:
range_faxes <- range_sp_coord +
  c(-1, 1) * (range_sp_coord[2] - range_sp_coord[1]) * 0.05


####### Create a list that will contains plots for each combination of axis:
plot_FRic <- list()

####### Compute all the combiantion we can get and the number of plots
axes_plot <- utils::combn(c("PC1", "PC2", "PC3", "PC4"), 2)
plot_nb   <- ncol(axes_plot)


######## Loop on all pairs of axes:
# for each combinaison of two axis:
for (k in (1:plot_nb)) {
  
  # get names of axes to plot:
  xy_k <- axes_plot[1:2, k]
  
  
  ####### Steps previously showed
  
  # a - Background:
  # get species coordinates along the two studied axes:
  sp_faxes_coord_xy <- sp_faxes_coord_fish[, xy_k]
  
  # Plot background with grey backrgound:
  plot_k <- mFD::background.plot(range_faxes = range_faxes, 
                                 faxes_nm = c(xy_k[1], xy_k[2]),
                                 color_bg = "grey95")
  
  
  # b - Global convex-hull:
  # Retrieve vertices coordinates along the two studied functional axes:
  vert <- mFD::vertices(sp_faxes_coord = sp_faxes_coord_xy,  
                        order_2D = FALSE, 
                        check_input = TRUE)
  
  plot_k <- mFD::pool.plot(ggplot_bg = plot_k,
                           sp_coord2D = sp_faxes_coord_xy,
                           vertices_nD = vert,
                           plot_pool = FALSE,
                           color_pool = NA,
                           fill_pool = NA,
                           alpha_ch =  0.8,
                           color_ch = "white",
                           fill_ch = "white",
                           shape_pool = NA,
                           size_pool = NA,
                           shape_vert = NA,
                           size_vert = NA,
                           color_vert = NA,
                           fill_vert = NA)
  
  
  # c - Assemblages convex-hulls and species:
  
  # Step 1: Species coordinates:
  # Epipelagic:
  ## filter species from Epipelagic:
  sp_filter_Epipelagic <- mFD::sp.filter(asb_nm = c("Epipelagic"),
                                      sp_faxes_coord = sp_faxes_coord_xy,
                                      asb_sp_w = depth_fish_biomass)
  ## get species coordinates (Epipelagic):
  sp_faxes_coord_Epipelagic <- sp_filter_Epipelagic$`species coordinates`
  
  
  # Upper mesopelagic:
  ## filter species from Upper mesopelagic:
  sp_filter_Upper_mesopelagic <- mFD::sp.filter(asb_nm = c("Upper mesopelagic"),
                                      sp_faxes_coord = sp_faxes_coord_xy,
                                      asb_sp_w = depth_fish_biomass)
  ## get species coordinates (Upper mesopelagic):
  sp_faxes_coord_Upper_mesopelagic<- sp_filter_Upper_mesopelagic$`species coordinates`
  
  
  # Lower mesopelagic:
  ## filter species from Lower mesopelagic:
  sp_filter_Lower_mesopelagic <- mFD::sp.filter(asb_nm = c("Lower mesopelagic"),
                                       sp_faxes_coord = sp_faxes_coord_xy,
                                       asb_sp_w = depth_fish_biomass)
  ## get species coordinates (Lower mesopelagic):
  sp_faxes_coord_Lower_mesopelagic <- sp_filter_Lower_mesopelagic$`species coordinates`
  
  # Bathypelagic:
  ## filter species from Bathypelagic:
  sp_filter_Bathypelagic <- mFD::sp.filter(asb_nm = c("Bathypelagic"),
                                                sp_faxes_coord = sp_faxes_coord_xy,
                                                asb_sp_w = depth_fish_biomass)
  ## get species coordinates (Bathypelagic):
  sp_faxes_coord_Bathypelagic <- sp_filter_Bathypelagic$`species coordinates`
  
  
  # Step 1 follow-up Vertices names:
  # Epipelagic:
  vert_nm_Epipelagic <- mFD::vertices(sp_faxes_coord = sp_faxes_coord_Epipelagic,
                                   order_2D = TRUE, 
                                   check_input = TRUE)
  
  # Upper mesopelagic:
  vert_nm_Upper_mesopelagic <- mFD::vertices(sp_faxes_coord = sp_faxes_coord_Upper_mesopelagic,
                                   order_2D = TRUE, 
                                   check_input = TRUE)
  
  # Lower mesopelagic:
  vert_nm_Lower_mesopelagic <- mFD::vertices(sp_faxes_coord = sp_faxes_coord_Lower_mesopelagic,
                                    order_2D = TRUE, 
                                    check_input = TRUE)
  
  # Bathypelagic:
  vert_nm_Bathypelagic <- mFD::vertices(sp_faxes_coord = sp_faxes_coord_Bathypelagic,
                                             order_2D = TRUE, 
                                             check_input = TRUE)
  
  
  # Step 2: plot convex-hulls and species of studied assemblages:
  plot_k <- mFD::fric.plot(ggplot_bg = plot_k,
                           asb_sp_coord2D = list("Epipelagic" = sp_faxes_coord_Epipelagic,
                                                 "Upper mesopelagic" = sp_faxes_coord_Upper_mesopelagic,
                                                 "Lower mesopelagic" = sp_faxes_coord_Lower_mesopelagic,
                                                 "Bathypelagic"= sp_faxes_coord_Bathypelagic),
                           asb_vertices_nD = list("Epipelagic" = vert_nm_Epipelagic,
                                                  "Upper mesopelagic" = vert_nm_Upper_mesopelagic,
                                                  "Lower mesopelagic" = vert_nm_Lower_mesopelagic,
                                                  "Bathypelagic"= vert_nm_Bathypelagic),
                           
                           plot_sp = TRUE,
                           
                           color_ch = NA,
                           fill_ch = c("Epipelagic" = "#00CED0",
                                       "Upper mesopelagic" = "#91A5B9",
                                       "Lower mesopelagic" = "#667A8D",
                                       "Bathypelagic"="#172B3B"),
                           alpha_ch = c("Epipelagic" = 0.7,
                                        "Upper mesopelagic" = 0.5,
                                        "Lower mesopelagic" = 0.4,
                                        "Bathypelagic"=0.3),
                           
                           shape_sp = c("Epipelagic" = 21,
                                        "Upper mesopelagic" = 22,
                                        "Lower mesopelagic" = 24,
                                        "Bathypelagic"=23),
                           size_sp = c("Epipelagic" = 1,
                                       "Upper mesopelagic" = 1,
                                       "Lower mesopelagic" = 1,
                                       "Bathypelagic"=1),
                           color_sp = c("Epipelagic" = "#00CED0",
                                        "Upper mesopelagic" = "#91A5B9",
                                        "Lower mesopelagic" = "#667A8D",
                                        "Bathypelagic"="#172B3B"),
                           fill_sp = c("Epipelagic" = "#00CED0",
                                       "Upper mesopelagic" = "#91A5B9",
                                       "Lower mesopelagic" = "#667A8D",
                                       "Bathypelagic"="#172B3B"),
                           
                           shape_vert = c("Epipelagic" = 21,
                                          "Upper mesopelagic" = 22,
                                          "Lower mesopelagic" = 24,
                                          "Bathypelagic"=23),
                           size_vert = c("Epipelagic" = 2,
                                         "Upper mesopelagic" = 2,
                                         "Lower mesopelagic" = 2,
                                         "Bathypelagic"=2),
                           color_vert = c("Epipelagic" = "#00CED0",
                                          "Upper mesopelagic" = "#91A5B9",
                                          "Lower mesopelagic" = "#667A8D",
                                          "Bathypelagic"="#172B3B"),
                           fill_vert = c("Epipelagic" = "#00CED0",
                                         "Upper mesopelagic" = "#91A5B9",
                                         "Lower mesopelagic" = "#667A8D",
                                         "Bathypelagic"="#172B3B"))
  
  ####### Save the plot on the plot list:
  plot_FRic[[k]] <- plot_k
  
}

#plot_FRic

patchwork_FRic <- (plot_FRic[[1]] + patchwork::plot_spacer() + patchwork::plot_spacer() +
                     plot_FRic[[2]] + plot_FRic[[4]] + patchwork::plot_spacer() +
                     plot_FRic[[3]] + plot_FRic[[5]] + plot_FRic[[6]]) +
  patchwork::plot_layout(byrow = TRUE, heights = rep(1, 3),
                         widths = rep(1, 3), ncol = 3, nrow = 3,
                         guides = "collect")
patchwork_FRic
```


- Only between epipelagic and bathypelagic layers 
```{r}
#| echo: true
#| label: plot_FRic
#| warning: false
#| message: false
#| fig-width: 12
#| fig-height: 8

plots_alpha$"fric"$"patchwork"
```

### __FDiv Functional Divergence__

- the proportion of the biomass supported by the species with the most extreme functional traits i.e. the ones located close to the edge of the convex-hull filled by the assemblage
```{r}
#| echo: true
#| label: plot_FDiv
#| warning: false
#| message: false
#| fig-width: 12
#| fig-height: 8

plots_alpha$"fdiv"$"patchwork"
```

### __FEve Functional Eveneness__

- the regularity of biomass distribution in the functional space using the Minimum Spanning Tree linking all species present in the assemblage.
```{r}
#| echo: true
#| label: plot_Feve
#| warning: false
#| message: false
#| fig-width: 12
#| fig-height: 8
plots_alpha$"feve"$"patchwork"
```


### __FSpe Functional Specialization__

- the biomass weighted mean distance to the mean position of species from the global pool (present in all assemblages).
```{r}
#| echo: true
#| label: plot_FSpe
#| warning: false
#| message: false
#| fig-width: 12
#| fig-height: 8

plots_alpha$"fspe"$"patchwork"
```

### __FDis Functional Dispersion__

- the biomass weighted deviation of species traits values from the center of the functional space filled by the assemblage i.e. the biomass-weighted mean distance to the biomass-weighted mean trait values of the assemblage.

```{r}
#| echo: true
#| label: plot_FDis
#| warning: false
#| message: false
#| fig-width: 12
#| fig-height: 8

plots_alpha$"fdis"$"patchwork"
```

### __FIde Functional Identity__
- the mean traits values for the assemblage. FIde is always computed when FDis is computed.

```{r}
#| echo: true
#| label: plot_FIde
#| warning: false
#| message: false
#| fig-width: 12
#| fig-height: 8

plots_alpha$"fide"$"patchwork"
```


## 3.2.Computing and plotting beta FD indices

__$\alpha$ & $\beta$ diversity__

- Moderate species turnover (29%) and very low functional turnover (1%). 
- Most of the trait dissimilarity between species is found within a depth layer and not across depths

```{r}
#| echo: true
#| label: rao_numbers
#| warning: false
#| message: false

#  Alpha, Beta and Gamma FD----
source(here::here("R", "Rao.r"))

partRao <- Rao(spxcom.matrix, dfunc = FD::gowdis(as.data.frame(spxtraits.matrix)), dphyl = NULL, 
                    weight = F, Jost = T, structure = NULL)

# Calculate proportions 
result_df <- data.frame(
  Category = rep(c("Functional diversity", "Taxonomic diversity"), each = 2),
  Metric = c("Alpha", "Beta"),
  Value = c(
    100 * partRao$FD$Mean_Alpha / partRao$FD$Gamma,
    partRao$FD$Beta_prop,
    100 * partRao$TD$Mean_Alpha / partRao$TD$Gamma,
    partRao$TD$Beta_prop
  )
)

result_df$Category <- factor(result_df$Category, levels = c("Taxonomic diversity", "Functional diversity"))

ggplot(result_df, aes(x = Category, y = Value, fill = Metric)) +
  geom_bar(position = "stack", stat = "identity", alpha = 0.6) +
  scale_fill_manual(values = c("#324B4E", "#95B0B4")) +
  labs(x = "", y = "Proportion of Alpha and Beta in Equivalent numbers",
       fill = "") +
  geom_text(aes(label = sprintf("%.2f", Value)), vjust = -0.5, position = position_stack(vjust = 0.5)) +
  theme_minimal()

```

- The function returns a list containing:
+ a dist object with beta indices values for each pair of assemblages:
```{r}
#| echo: true
#| label: compute_beta_FD
#| warning: false
#| message: false

beta_fd_indices_fish <- mFD::beta.fd.multidim(
      sp_faxes_coord   = sp_faxes_coord_fish[ , c("PC1", "PC2", "PC3", "PC4")],
      asb_sp_occ       = asb_sp_fish_occ,
      check_input      = TRUE,
      beta_family      = c("Jaccard"),
      details_returned = TRUE)

head(beta_fd_indices_fish$"pairasb_fbd_indices", 10)
```
+ a vector containing the FRic value for each assemblage retrieved through the details_beta list:

```{r}
#| echo: true
#| label: asb_FRic
#| warning: false
#| message: false

beta_fd_indices_fish$"details"$"asb_FRic"
```
+ a list of vectors containing names of species being vertices of the convex hull for each assemblage retrieved through the details_beta list:
```{r}
#| echo: true
#| label: asb_vertices
#| warning: false
#| message: false

beta_fd_indices_fish$"details"$"asb_vertices"
```

+ overlap between convex hulls shaping each of the two species assemblages.
```{r}
#| echo: true
#| label: plot_beta_FD_epi_up
#| warning: false
#| message: false
#| fig-width: 12
#| fig-height: 10

beta_plot_fish <- mFD::beta.multidim.plot(
  output_beta_fd_multidim = beta_fd_indices_fish,
  plot_asb_nm             = c("Epipelagic", "Upper mesopelagic"),
  beta_family             = c("Jaccard"),
  plot_sp_nm              = c("Maurolicus_muelleri", "Lampanyctus_crocodilus", "Argyropelecus_olfersii"),
  faxes                   = paste0("PC", 1:4),
  name_file               = NULL,
  faxes_nm                = NULL,
  range_faxes             = c(NA, NA),
  check_input             = TRUE)

beta_plot_fish$"patchwork"
```


```{r}
#| echo: true
#| label: plot_beta_FD_up_lw
#| warning: false
#| message: false
#| fig-width: 12
#| fig-height: 10

beta_plot_fish <- mFD::beta.multidim.plot(
  output_beta_fd_multidim = beta_fd_indices_fish,
  plot_asb_nm             = c("Upper mesopelagic", "Lower mesopelagic"),
  beta_family             = c("Jaccard"),
  plot_sp_nm              = c("Maulisia_mauli", "Evermannella_balbo", "Borostomias_antarcticus"),
  faxes                   = paste0("PC", 1:4),
  name_file               = NULL,
  faxes_nm                = NULL,
  range_faxes             = c(NA, NA),
  check_input             = TRUE)

beta_plot_fish$"patchwork"
```


```{r}
#| echo: true
#| label: plot_beta_FD_lw_b
#| warning: false
#| message: false
#| fig-width: 12
#| fig-height: 10

beta_plot_fish <- mFD::beta.multidim.plot(
  output_beta_fd_multidim = beta_fd_indices_fish,
  plot_asb_nm             = c("Lower mesopelagic", "Bathypelagic"),
  beta_family             = c("Jaccard"),
  plot_sp_nm              = c("Anoplogaster_cornuta", "Holtbyrnia_anomala", "Photostylus_pycnopterus"),
  faxes                   = paste0("PC", 1:4),
  name_file               = NULL,
  faxes_nm                = NULL,
  range_faxes             = c(NA, NA),
  check_input             = TRUE)

beta_plot_fish$"patchwork"
```

# 4. Functional rarity

## 4.1 Different indices of functional rarity

<span style="color:#2596be;">__Functional originality indices__</span>: 

+ __Functional distinctiveness__ is the mean of dissimilarity of the focal species to all the other species of the set of interest. It can be abundance-weighted if needed.

+ __Functional uniqueness__ is the smallest dissimilarity that exists between the focal species and the all other species in the set. It does not consider the abundance of any species.

<span style="color:#2596be;">__Rarity indices__</span>: 

+ __Scarcity__ is proportional to the relative abundance of the species. It gets close to one when the species is (relatively) rare and close to 0 when its dominant

+ __Restrictedness__ is 1 minus the ratio of sites a species occupy over the total number of sites.

## 4.2.Computing functional rarity
### 4.2.1 Functional originality at regional scale

 - For the choice or dissimilarity matrix we can use the raw dissimilarity matrix computed directly on raw traits values among species: 
```{r}
#| echo: true
#| label: distinctiveness_global
#| warning: false
#| message: false

sp_di <- funrar::distinctiveness_global(sp_dist_fish, di_name = "distinctiveness")

htmltools::tagList(DT::datatable(sp_di))
```

- Another option would be to compute a new functional dissimilarity matrix based on the selected functional axes. One advantage of the latter is that it already takes into account the correlation between traits (recompute regional functional distinctiveness based on the n selected functional axes. Because the space comes from a PCA, we can directly use euclidean distance): 
```{r}
#| echo: true
#| label: distinctiveness_n_axis
#| warning: false
#| message: false

new_dissim <- dist(sp_faxes_coord_fish[, c("PC1", "PC2", "PC3", "PC4")])

sp_di_alt <- funrar::distinctiveness_global(new_dissim, di_name = "alt_di")

#We can now compare both distinctiveness values.

sp_all_di <- merge(sp_di, sp_di_alt, by = "species")

plot(sp_all_di$distinctiveness, sp_all_di$alt_di)
cor.test(sp_all_di$distinctiveness, sp_all_di$alt_di)
```
Both seems very correlated, so in our case using either one should be fine. However, it can be better to use dissimilarity based on a reduced number of well-defined axes because: (1) there are more interpretable thanks to the multivariate analysis, (2) the first one contain of the most information, (3) they explicitly take into account potentially strong correlations between provided traits. We’ll stick here with raw dissimilarity for the sake of simplicity

To compute uniqueness at regional scale we also need the regional level functional dissimilarity matrix with the uniqueness() function, and the site-species matrix:
```{r}
#| echo: true
#| label: uniqueness
#| warning: false
#| message: false

sp_ui <- funrar::uniqueness(
  pres_matrix = depth_fish_biomass,
  as.matrix(sp_dist_fish)
)

quantile(sp_ui$Ui, probs = seq(0, 1, by = 0.1))

htmltools::tagList(DT::datatable(sp_ui))
```
Based on these results we see that _Anoplogaster cornuta_, and _Malacosteus niger_ are the most isolated fish in the functional space. Meaning that they have the most distant nearest neighbors.

### 4.2.2 Functional originality at local scale

```{r}
#| echo: true
#| label: sp_local_di
#| warning: false
#| message: false

sp_local_di <- funrar::distinctiveness(
  depth_fish_biomass, as.matrix(sp_dist_fish)
)
sp_local_di[1:4, 1:10]
identical(dim(sp_local_di), dim(depth_fish_biomass))
```

To compute uniqueness at the site scale, we must use a more complex expression as it was not envisioned for local computation:
```{r}
#| echo: true
#| label: depth_ui
#| warning: false
#| message: false

depth_ui <- apply(
  depth_fish_biomass, 1,
  function(single_site, dist_m) {
    single_site = single_site[single_site > 0 & !is.na(single_site)]
    funrar::uniqueness(t(as.matrix(single_site)), dist_m)
  }, dist_m = as.matrix(sp_dist_fish)
)

head(depth_ui[1])
```

As we had to manually build the function to compute the local uniqueness the results are strangely formatted.

We provide here a function that can help them to be more easily read:

```{r}
#| echo: true
#| label: depth_u_fct
#| warning: false
#| message: false

depth_ui <- lapply(names(depth_ui), function(x) {
  single_depth = depth_ui[[x]]
  single_depth$site = x
  
  return(single_depth)
})

depth_ui <- do.call(rbind, depth_ui)

#Then we can again look at the apple to see how its uniqueness varies across depths.

subset(depth_ui, species == "Melanostomias_bartonbeani")
```

4.3.3.Rarity indices

__scarcity__:
```{r}
#| echo: true
#| label: scarcity
#| warning: false
#| message: false

rel_weights = funrar::make_relative(depth_fish_biomass)

si =  funrar::scarcity(rel_weights)
summary(si)
```

__restrictiveness__: 
```{r}
#| echo: true
#| label: restrictiveness
#| warning: false
#| message: false

ri = funrar::restrictedness(depth_fish_biomass)
summary(ri)
```

## 4.3 Plotting functional rarity
### 4.3.1 Plotting functional originality

option to be able to colour species according to their functional originality (and not use the ready-made functions in the mfd package)
```{r}
#| echo: true
#| label: plot_si_ri
#| warning: false
#| message: false
#| fig-width: 13
#| fig-height: 10

library("ggplot2")

# Make a summary data.frame
sp_coord_di_ui <- as.data.frame(sp_faxes_coord_fish[, 1:2])
sp_coord_di_ui$species <- rownames(sp_coord_di_ui)
rownames(sp_coord_di_ui) <- NULL
sp_coord_di_ui <- sp_coord_di_ui[, c(3, 1, 2)]
sp_coord_di_ui <- merge(sp_coord_di_ui, sp_di, by = "species")
sp_coord_di_ui <- merge(sp_coord_di_ui, sp_ui, by = "species")


plot_reg_distinctiveness <- ggplot(sp_coord_di_ui, aes(PC1, PC2)) +
  geom_hline(yintercept = 0, linetype = 2) +
  geom_vline(xintercept = 0, linetype = 2) +
  geom_point(aes(color = distinctiveness), size=4) +
  ggrepel::geom_text_repel(aes(label = species), size=3) +
  scale_color_gradient(high = "#914568", low = "#6BA1B9", "Functional\nDistinctiveness")+
  theme_bw() +
  theme(aspect.ratio = 1)

plot_reg_uniqueness <- ggplot(sp_coord_di_ui, aes(PC1, PC2)) +
  geom_hline(yintercept = 0, linetype = 2) +
  geom_vline(xintercept = 0, linetype = 2) +
  geom_point(aes(color = Ui), size=4) +
  ggrepel::geom_text_repel(aes(label = species), size=3) +
  scale_color_gradient(high = "#914568", low = "#6BA1B9","Functional\nUniqueness") +
  theme_bw() +
  theme(aspect.ratio = 1)

patchwork::wrap_plots(plot_reg_distinctiveness, plot_reg_uniqueness)
```

- As was done with mFD to correlate the functional axes with species’ traits we can correlate functional distinctiveness to specific traits in order to see which traits are mainly driving distinctiveness.

- Regarding local level functional originality indices, the visualization can be more difficult to grasp and depends highly on the question. Would you rather focus on visualizing the functional distinctiveness of one species across communities? Compare the distribution of functional distinctiveness values across communities?

- One idea to keep in mind is that averaging functional distinctiveness per community is exactly equal to computing functional dispersion. Functional originality is computed on a species basis, so we should be aware that if we are rather interested by community properties than we can compute functional diversity metrics which are much more appropriate.

```{r}
local_di_ap <- as.data.frame(sp_local_di[, c(1: 11)])
local_di_ap$depth <- rownames(local_di_ap)
```

### 4.3.2. Plotting rarity
 - __Functional Distinctiveness__
```{r}
#| echo: true
#| label: plot_dist_ri_reg
#| warning: false
#| message: false
#| fig-width: 6
#| fig-height: 6

sp_di_ri <- merge(sp_di, ri, by = "species")
sp_di_ri_ui <- merge(sp_di_ri, sp_ui, by = "species")

plot_dist_ri_reg <-ggplot(sp_di_ri, aes(distinctiveness, Ri)) +
  geom_point() +
  ggrepel::geom_text_repel(aes(label = species), max.overlaps=22, size=3) +
  labs(x = "Functional Distinctiveness", y = "Geographical Restrictedness") +
  theme_bw() +
  theme(aspect.ratio = 1)

plot_dist_ri_reg
```
On this visualization we can clearly see that _Anoplogaster cornuta_ is overall the most distinct species while being quite restricted in terms of depth. On the other hand, the two Myctophidae _Lampanyctus ater_ and _Lobianchia_gemellarii_ are the most functionally common and regionally widespread species (low restrictedness).

```{r}
#| echo: true
#| label: plot_dist_ri_reg_depth
#| warning: false
#| message: false
#| fig-width: 7
#| fig-height: 7

# median depth of species 
median_depth_fish <- depth_distribution%>%
  group_by(species)%>%
  summarise(median_depth= median(depth))

sp_di_ri_depth <- sp_di_ri%>%
  left_join(median_depth_fish)

sp_di_ri_depth_plot <- ggplot(sp_di_ri_depth, aes(distinctiveness, Ri)) +
  geom_point(aes(col=median_depth), size=3) +
  ggrepel::geom_text_repel(aes(label = species), max.overlaps=22, size=3) +
  labs(x = "Functional Distinctiveness", y = "Geographical Restrictedness") +
  scale_color_gradient(high = "#00263A", low = "#C5F8FF","Median depth (m)") +
  theme_bw() +
  theme(aspect.ratio = 1)

sp_di_ri_depth_plot
```


+ Density of distinctiveness values
```{r}
#| echo: true
#| label: plot_dist_values_density
#| warning: false
#| message: false

quant = quantile(sp_di$distinctiveness, probs = seq(0, 1, 0.10))
labels_quant = paste(names(quant)[-length(quant)], names(quant)[-1], sep = "-")

di_density = data.frame(density(sp_di$distinctiveness)[c("x", "y")])
di_density = subset(di_density, x >= quant[[1]] & x <= quant[[length(quant)]])
di_density$quant = cut(di_density$x, breaks = quant)   
quant = quantile(sp_di$distinctiveness, probs = seq(0, 1, 0.10))
labels_quant = paste(names(quant)[-length(quant)], names(quant)[-1], sep = "-")

ggplot(data = di_density, aes(x = x, y = y)) +
  geom_area(aes(fill = quant)) +
  scale_fill_brewer(palette = "RdYlBu", labels = labels_quant,
                    name = "Quantile") +
  geom_line(size = 1) +
  xlab("Distinctiveness values") +
  ylab("Frequency") +
  theme_minimal()

```


- __Functional Uniqueness__
```{r}
#| echo: true
#| label: plot_ui_ri_reg
#| warning: false
#| message: false
#| fig-width: 6
#| fig-height: 6

plot_ui_ri_reg <- ggplot(sp_di_ri_ui, aes(Ui, Ri)) +
  geom_point() +
  ggrepel::geom_text_repel(aes(label = species), max.overlaps=22, size=3) +
  labs(x = "Functional Uniqueness", y = "Geographical Restrictedness") +
  theme_bw() +
  theme(aspect.ratio = 1)

plot_ui_ri_reg
```

```{r}
#| echo: true
#| label: plot_ui_ri_reg_depth
#| warning: false
#| message: false
#| fig-width: 7
#| fig-height: 7

sp_di_ri_ui_depth <- sp_di_ri_ui%>%
  left_join(median_depth_fish)

plot_ui_ri_reg_depth <- ggplot(sp_di_ri_ui_depth, aes(Ui, Ri)) +
  geom_point(aes(col=median_depth), size=3) +
  ggrepel::geom_text_repel(aes(label = species), max.overlaps=22, size=3) +
  labs(x = "Functional Uniqueness", y = "Geographical Restrictedness") +
  scale_color_gradient(high = "#00263A", low = "#C5F8FF","Median depth (m)") +
  theme_bw() +
  theme(aspect.ratio = 1)

plot_ui_ri_reg_depth
```
- plot local scale measurements:

__bathypelagic layer__
```{r}
#| echo: true
#| label: sp_local_di_si
#| warning: false
#| message: false

sp_local_di_df <- funrar::matrix_to_stack(
  sp_local_di, value_col = "local_di", row_to_col = "depth",
  col_to_col = "species"
)
sp_local_si_df <- funrar::matrix_to_stack(
  si, value_col = "local_si", row_to_col = "depth", col_to_col = "species"
)

sp_local_di_si <- merge(
  sp_local_di_df, sp_local_si_df, by = c("depth", "species")
)

head(sp_local_di_si)
```

```{r}
#| echo: true
#| label: plot_local_di_si
#| warning: false
#| message: false

plot_local_di_si <- ggplot(sp_local_di_si, aes(local_di, local_si)) +
  geom_point(alpha = 1/3) +
  labs(x = "Functional Distinctiveness", y = "Scarcity") +
  theme_bw() +
  theme(aspect.ratio = 1)

plot_local_di_si
```
```{r}
#| echo: true
#| label: plot_local_di_si_relation
#| warning: false
#| message: false

ggplot(sp_local_di_si, aes(local_di, local_si)) +
  geom_point(alpha = 0.5) +
  labs(x = "Functional Distinctiveness", y = "Scarcity") +
  theme_bw() +
  theme(aspect.ratio = 1)+
  geom_smooth(method = "lm", alpha=0.1, size=1.2, col= "#00263A")+
  ggpmisc::stat_poly_eq(formula = y ~ x, 
                        aes(label = paste(..eq.label.., ..rr.label.., ..p.value.label.. 
                                          , ..n.label..,sep = "*`,`~")),
                        parse = TRUE,
                        size=3.38,
                        label.x.npc = "right",
                        label.y.npc = "bottom",
                        vstep = -0.0005)

```

- there seems to be a correlation (even if R²=0.04) between the rarity of fish and their distinctiveness 
